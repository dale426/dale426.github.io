<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[less不只是用来嵌套]]></title>
    <url>%2Fblog%2F2020%2Fothers%2Fless%E4%B8%8D%E5%8F%AA%E6%98%AF%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[tips: less不只是用来写嵌套的，还有很多实用功能和技巧 开始之前 介绍下如何实时调试学习less； 安装less依赖 1npm install -g less 编写.less文件, 然后进行编译 1npx lessc xxx.less 以上命令就可以在控台输出编译过后的css，如果想编译后在一个文件中显示，使用如下命令： 1npx lessc xxx.less xxx.css 如此就会在目录中看到编译过后的css了； less使用指南——正文开始—— 变量12@width: 10px;@height: @width + 10px; 混合 基础混合123456789.bese &#123; color: red; font-size: 14px;&#125;.header &#123; .base(); /* 可以使用一个类当做函数混合使用 */ background: #fff;&#125; 带参数的mixinsHeight mixin 支持传入一个参数来确定高度和行高，默认为 10px 1234567891011:root &#123; --primary: red;&#125;.long(@w: 10px, @h: 1px, @pd) &#123; width: @w; height: @h; color: @pd;&#125;.main8 &#123; .long(@w: 700px, 30px, var(--primary));&#125; 不定传参 123456789.padding(...)&#123; padding: @arguments;&#125;.div1&#123; .padding(1px, 2px)&#125;.div2&#123; .padding(1px, 2px, 3px)&#125; 嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546.head &#123; font-size: 14px; .title &#123; color: red; &#125; .nav &#123; width: 200px; &#125;&#125;/* &amp; 表示当前选择器 .clearfix */.clearfix &#123; display: block; zoom: 1; &amp;:after &#123; content: " "; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; &#125;&#125;/* &amp; 拼接用法 .clearfix */.main &#123; margin: 10px; &amp;_nav &#123; border: 10px solid red; &#125; &amp;-aside &#123; padding: 5px; &#125;&#125;/ ** 编译后： **/.main &#123; margin: 10px;&#125;.main_nav &#123; border: 10px solid red;&#125;.main-aside &#123; padding: 5px;&#125; 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算 如果可能的话，算术运算符在加、减或比较之前会进行单位换算。 计算的结果以最左侧操作数的单位类型为准 123456789101112@base: 2cm * 3mm; // 结果是 6cm// 所有操作数被转换成相同的单位@conversion-1: 5cm + 10mm; // 结果是 6cm@conversion-2: 2 - 3cm - 5mm; // 结果是 -1.5cm// conversion is impossible@incompatible-units: 2 + 5px - 3cm; // 结果是 4px// example with variables@base: 5%;@filler: @base * 2; // 结果是 10%@other: @base + @filler; // 结果是 15% calc特例为了与 CSS 保持兼容，calc() 并不对数学表达式进行计算，但是在嵌套函数中会计算变量和数学公式的值。 12@var: 50vh/2;width: calc(50% + (@var - 20px)); // 结果是 calc(50% + (25vh - 20px)) 转义转义（Escaping）允许你使用任意字符串作为属性或变量值。任何 ~&quot;anything&quot; 或 ~&#39;anything&#39; 形式的内容都将按原样输出，除非 interpolation。 1234567891011121314@min768: ~"(min-width: 768px)";.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; /* 3.5+版本中也可以这样写 */@min768: (min-width: 768px);.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; 编译后： 12345@media (min-width: 768px) &#123; .element &#123; font-size: 1.2rem; &#125;&#125; ### 命名空间和访问符号有时候需要将一些 css 方法封装在一个命名的空间中，不影响其他的样式可以使用, 可以使用 # 或者 . #method() { .class {} } .method() { .class {} } 1234567891011121314151617#myclass() &#123; /* 定义可一个 myclass 方法，将常用的class方法放在其中 */ .title &#123; color: red; padding: 12px; &#125; .content &#123; border: 2px solid red; &#125; .classa &#123;&#125; .classb &#123;&#125;&#125; /* 使用 */.main &#123; font-size: 20px; #myclass.title(); /* 访问符号 或者 #myclass &gt; .title; */ #myclass &gt; .content;&#125; 编译后： 123456.main &#123; font-size: 20px; color: red; padding: 12px; border: 2px solid red;&#125; 注意： 如果 #myclass() 不写 () 直接写成 #myclass {...} 将会输出到编译后的 css 中 去掉括号编译如下：12345678910111213141516/* 方法也输出在css中了--- */#myclass &#123;&#125;#myclass .title &#123; color: red; padding: 12px;&#125;#myclass .content &#123; border: 2px solid red;&#125;/* 方法也输出在css中了--- */.main &#123; font-size: 20px; color: red; padding: 12px;&#125; 映射 嵌套映射普通样式中的嵌套都可以使用映射 [] 直接取值，自定义的属性也能直接取值， 命名空间中的嵌套也能直接取值；123456789101112131415161718192021222324252627282930313233343536373839#myclass() &#123; /* 定义可一个 myclass 方法，将常用的class方法放在其中 */ .title &#123; color: red; padding: 12px; &#125; .content &#123; border: 2px solid red; &#125; primary: blue; /* 自定义的属性 */ secondary: green; /* 自定义的属性 */&#125; /* -------------------------------------------------------------- */.youclass() &#123; border: 1px solid blue; .nav &#123; color: darkblue; &#125; .tap &#123; padding: 20px; &#125; mycolor: red;&#125; /* -------------------------------------------------------------- */ /* 使用 */.main2 &#123; font-weight: bold; color: #myclass[primary]; /* 使用映射 */ background: #myclass[secondary]; /* 使用映射 */&#125;.main3 &#123; border: .youclass[border]; color: .youclass[mycolor]; .youclass.tap();&#125; 编译后： 12345678910.main2 &#123; font-weight: bold; color: blue; background: green;&#125;.main3 &#123; border: 1px solid blue; color: red; padding: 20px;&#125; 规则集映射可以将变量规则集合作为映射； 1234567891011@color: blue; /* 规则集合 */@colorList: &#123; first: red; second: red - 100; third: @color - 30;&#125;.app &#123; color: @color; border-color: @colorList[second]; /* 使用规则集合 */&#125; 编译后 1234.app &#123; color: blue; border-color: #9b0000;&#125; 作用域Less 中的作用域与 CSS 中的作用域非常类似。首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承。 12345678@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125; 与 CSS 自定义属性一样，混合（mixin）和变量的定义不必在引用之前事先定义。因此，下面的 Less 代码示例和上面的代码示例是相同的： 12345678@var: red;#page &#123; #header &#123; color: @var; // white &#125; @var: white;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度&空间复杂度]]></title>
    <url>%2Fblog%2F2019%2Fjs%2Fcommon%2Fsortbase%2F</url>
    <content type="text"><![CDATA[【基础知识】考量一个算法的维度 时间复杂度时间频度 一个算法执行所耗费的时间。 从理论上讲时间是不能计算出来的，必须上机运行测试才能知道，但我们不可能也没有必要对每个算法都上机运行测试，我们只需要知道哪个算法花费的时间多，哪个算法花费的时间少即可。并且一个算法花费的时间与算法中语句的执行次数成正比，所以一个算法中语句执行的次数多，它花费时间就多。 一个算法中的语句执行次数称为语句频度或时间频度，记为O(n)。 计算时间复杂度的具体步骤 找出算法中的基本语句 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 用大Ο记号表示算法的时间性能 将基本语句执行次数的数量级放入大Ο记号中。 如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加; 时间复杂度O(1)123int a=2;int b=2;int c=2; 以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 O(n)12345int i, n = 100, sum = 0;for( i=0; i &lt; n; i++ ) /执行n+1次/&#123; sum = sum + i;&#125; 这段代码的时间复杂度为O(n)，因为循环体中的代码需要执行n次。 O(n*n)12345678int i, j, n = 100;for( i=0; i &lt; n; i++ ) /执行n+1次/&#123; for( j=0; j &lt; n; j++ ) /执行n*(n+1)次/ &#123; printf(“I love you!”); /执行n*n次/ &#125;&#125; 根据以上代码，n=100，也就是说外层循环每执行一次，内层循环就执行100次，那么程序要运行完两个循环，需要执行100*100次，也就是n的平方，所以这段代码的时间复杂度为O(n*n)。 那么问题就来了，要是有三个这样的嵌套循环，时间复杂度就是n*n*n。 特殊的–&gt; 选择排序法12345678int i, j, n = 100;for( i=0; i &lt; n; i++ )&#123; for( j=i; j &lt; n; j++ ) &#123; printf("选择排序"); &#125;&#125; 根据以上代码分析，当i=0时，内循环执行了n次；当i=1时，内循环则执行n-1次……当i=n-1时，内循环执行1次，所以总的执行次数是：n+(n-1)+(n-2)+…+1 = n(n+1)/2。用我们推导大O的攻略，第一条忽略，因为没有常数相加。第二条只保留最高项，所以n/2这项去掉。第三条，去除与最高项相乘的常数，最终得时间复杂度为O(n2)。 空间复杂度算法中用到的变量个数 O(n)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典算法-选择排序&冒泡排序]]></title>
    <url>%2Fblog%2F2019%2Fjs%2Fcommon%2Fsort001%2F</url>
    <content type="text"><![CDATA[【重拾算法】: 入门经典算法回顾，冒泡与排序 选择排序法选择排序法是在要排序的一组数中，选出最小（或最大）的一个数与第一个位置的数交换；在剩下的数当中找最小的与第二个位置的数交换，即顺序放在已排好序的数列的最后，如此循环，直到全部数据元素排完为止。1var arr = [4, 1, 6, 8, 34, 23, 5, 6 ,89, 28, 33] 1234567891011121314151617181920function selectSort(sortArr) &#123; let arr = JSON.parse(JSON.stringify(sortArr)); let min; for (let i = 0, l = arr.length; i &lt; l-1; i++) &#123; min = i; // 查找最小的那个数的索引 for (let k = i + 1; k &lt; l; k ++) &#123; if (arr[i] &gt; arr[k]) &#123; min = k; &#125; &#125; if (min !== i) &#123; let temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; // 快速交换两个变量 [arr[i], arr[k]] = [arr[k], arr[i]] &#125; return arr;&#125; 时间复杂度： 最好的情况下，正序列排列，即min每次是最小的数，只执行了内层的循环 n-1 次，时间复杂度为 O(n) 最坏的情况下，内层基本语句的执行次数为n+(n-1)+(n-2)+…+1 = n(n+1)/2， 所以时间复杂度为O(n*n) 空间复杂度为: O(1) 冒泡排序法冒泡排序算法的原理如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。12345678910111213function bubbleSort(sortArr) &#123; let arr = JSON.parse(JSON.stringify(sortArr)); for(let i = 0; i &lt; arr.length - 1; i++) &#123; /* 外循环为排序趟数，len个数进行len-1趟 */ for (let j = 0; j &lt; arr.length - i -1; j ++ ) &#123; /* 内循环为每趟比较的次数，第i趟比较len-i次 */ if (arr[j] &gt; arr[j+1]) &#123; let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 时间复杂度： 最好情况下，正序排列，只需要内层循环 n-1 趟，所以时间复杂度为 O(n) 最坏情况下，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较, 所以内层的基本语句执行次数为 (n-1)*n / 2次， 时间复杂度为 O(n*n) 空间复杂度：O(1)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS变量]]></title>
    <url>%2Fblog%2F2019%2Fothers%2Fcaa-var%2F</url>
    <content type="text"><![CDATA[随着Web应用程序变得越来越大，CSS变得越来越大，越来越多，而且很多时候都很乱，在良好的上下文中使用CSS变量，为您提供重用和轻松更改重复出现的CSS属性的机制。 在“纯粹的”CSS支持变量之前，我们有像Less和Sass这样的预处理器。但是它们需要在使用前进行编译，因此（有时）会增加额外的复杂性。 变量的声明在变量名前面添加两根连词线--1234body &#123; --bg: #7f583f; --fz: 20px;&#125; 变量名对大小写敏感； var()函数var()用于读取变量；1234.gtoup &#123; font-size: var(--fz); background: var(--bg);&#125; var()函数还可以使用第二个参数，表示变量的默认值，如果变量不存在就是用默认值。123.group2 &#123; color: var(--co, green);&#125; 第二个参数不处理内部的逗号或者空格，都会视为一个参数；12var(--font-stack, "Ro boto", "Helvetica");var(--pad, 10px 15px 20px); var()函数中还可以使用变量声明1234:root &#123; --primary-color: red; --logo-text: var(--primary-color);&#125; 变量值的类型 如果变量值是一个字符串，可以与其他字符串拼接；1234:root &#123; --bar: 'hello'; --foo: var(--bar)' 你好';&#125; 实例1234body::after &#123; content: var(--foo)'12345'; /* 输出 hello 你好 12345 */&#125; 数字不可以直接连接，需要使用calc()函数链接 123456:root &#123; --mt: 20;&#125;.group &#123; margin-top: calc(var(--mt) * 1px);&#125; 如果变量值带有单位，就不能写成字符串。1234567891011/* 无效 */.foo &#123; --foo: '20px'; font-size: var(--foo);&#125;/* 有效 */.foo &#123; --foo: 20px; font-size: var(--foo);&#125; 作用域变量的作用域读取时，优先级高的生效，和css层叠一致；1234567body &#123; --foo: green;&#125;.content &#123; --foo: red;&#125; 在上面的例子中，–foo在选择器为 .content的范围内优先级更高； 因此通常将全局的变量放在根元素:root中； :root选择器用匹配文档的根元素。在HTML中根元素始终是HTML元素。 响应式布局可以在响应式布局的media命令中声明变量，使得不同的屏幕宽度有不通的变量值； 123456789101112131415/* 普通读取这个 */body &#123; --bg: red; --secondary: #F7EFD2;&#125;/* 宽度大于768时 读取这个 */@media screen and (min-width: 768px) &#123; body &#123; --bg: green; &#125;&#125;.group2 &#123; background: var(--bg);&#125; 兼容性处理对于不支持css变量的属性，使用如下写法；1234.group &#123; color: red; color: var(--bg);&#125; 或者使用@support检测；1234567@supports ( (--bg: 0)) &#123; /* supported */&#125;@supports ( not (--bg: 0)) &#123; /* not supported */&#125; JavaScript操作CSS变量 js检测浏览器是否支持CSS变量； 12345678910const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports('bg', 0);if (isSupported) &#123; /* supported */&#125; else &#123; /* not supported */&#125; js操作CSS变量 123456789// 设置变量document.body.style.setProperty('--bg', 'red');// 读取变量document.body.style.getPropertyValue('--bg').trim();// 'red'// 删除变量document.body.style.removeProperty('--bg');]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么你要写博客？]]></title>
    <url>%2Fblog%2F2019%2Fothers%2Fwhyiblog%2F</url>
    <content type="text"><![CDATA[记录自己的生活、成长，以及技术、心智成熟的历程，回过头看自己之前写的东西，如果觉得自己那个时候很傻白甜，那说明此刻的你相比较于之前成长了； 提供持续学习的动力例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。 积累更多的知识写并不是单纯的写。 例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。 例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。 提高将事情讲清楚的能力很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。 分享带来的连锁反应“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》 互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。 帮你找到志同道合的人在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。 如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。 即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》 记录成长隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。 更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！ 培养持续做一件事情的能力开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」 让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。 你不相信？你不试试你怎么知道？ 默默地持续做一件事是一种难得的能力，也是一种难得的品质。 讨论反思每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。 互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。 搜寻到你意想不到东西世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。 例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。 一个人在做一件属于自己的事很多你认为自己很牛逼的事情都是自己一个人做出来。 别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？ 如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》 互联网的身份识别：一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。 这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏 最后你可能想不到在白纸的左边（不值得写博客的原因）写什么了，想不到写个「博客时代已经过去」或者「我没有时间」也可以，但与此同时，你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」。 本文转载自 陈素封——为什么你要写博客？]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端 H5 开发问题汇总]]></title>
    <url>%2Fblog%2F2019%2Fmobile%2Fh5-dev-summary%2F</url>
    <content type="text"><![CDATA[各个大佬的h5开发问题总结以及解决方案 移动web总结–吕小鸣前端博客 移动端问题列表–腾讯AlloyTeam]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何成为一个优秀的程序员~]]></title>
    <url>%2Fblog%2F2019%2Fothers%2FExcellent-programmer%2F</url>
    <content type="text"><![CDATA[编程是一项聪明人玩的游戏，它既是对智力的考验，也是对习惯的考验，智力的好坏取决于父母的基因，人们无从左右，但习惯的好坏却是可以不断培养。一项由美国芝加哥大学国家研究组织进行的综合社会调查，公布了“十大最痛苦工作”排行榜，其中IT主管成了最让人痛苦的职业。程序员如何才能让自己的“痛苦”的职业不那么痛苦呢？ 世间少有天才，所谓天才，只不过是把别人喝咖啡的功夫都用在工作上了。所以，对于绝大多数还称不上天才的程序员而言，以下这些编程的好习惯都是无数前人智慧的结晶，具有相当意义的参考价值。 （1）估算解决问题所需要的时间。为自己定一个时间限制，如果在这期间未能解决问题，那就去寻求帮助，或到网上找答案，而不是尝试去做“超级堆码员”，因为很多问题，你很少会是这个世界上唯一一个遇到的人。站在别人的肩膀上，会让你的形象变得高大、伟岸。 （2） 理解编程语言的原理。三流的人才懂应用，二流的人才懂开发，一流的人才懂原理，要想学好一门编程语言，掌握语言的原理是必不可少的。各种语言之间存在相似之处，你所选择的语言，你应该觉得“舒服”，并且能够写出有效（而且简洁）的代码。最重要的，让语言去适应项目，反之亦然。 （3） 重视，但不过于注重程序的设计模式。在大中型系统中，引入设计模式，往往能极大地提高系统研发的效率。但设计模式并非万金油，有时候，写一个简单的算法，要比引入某种模式更容易。如果一个100行就能写完的脚本，最终却使用了8个类，10个接口，外加一大堆范式和标记符，结果导致97%的代码不做任何事情，这种优化又有什么意义？在多数情况下，程序代码应是简单易懂，而不应该是老太婆的裹脚布—又臭又长。 （4） 做好版本控制，并及时备份代码。编码时，最痛苦的事情不是有多少bug没解决，而是突然停电了，一天的工作却没有保存。版本控制时，最好使用版本控制软件。无论什么时候改变自己的程序，它们都会将其保存为.bak文件。 （5） 对项目文件归类保存。可以把项目文件放到SOURCE、HEADERS、MAKE、EXES等不同的文件夹中。如果工程包含多个源文件，则可以建立一个README文件，注明每个源文件、数据文件、临时文件以及日志文件(如果有的话)的作用。还可以注明编译和运行步骤。 （6）动手编码之前，先做好分析和设计。项目开始之初，不要急于编码，而应该做好详细的需求与设计。做需求确实很难，不然也不会有程序员发出这样的牢骚：需求无非两种，一种是“你妹的，这还用做？”，另一种是“你妹的，这也能做？”不仅如此，实践和分析设计过程也可存在很大的矛盾，但是好的分析会避免过早走向一个错误的方向，好的设计可以避免混乱，否则，很有可能忙活了很久，最后发现方向错了或是架构错了，需要不断的监测、修改与调试，甚至是完全推翻以前的工作，重新设计，工作的成果看起来更像一个三岁小孩的涂鸦，而不是意见艺术作品，“捡了芝麻却丢了西瓜”。永远不要在没有任何设计的前提下就开始编码，除非所编代码不重要。 （7）多向其他优秀程序员学习。你有一个苹果，我也有一个苹果，我们交换苹果，你我还是有一个苹果；你有一种思想，我也有一种思想，我们交换思想，你我就有了两种思想。其实，一个人能走多远，要看他与谁同行；一个人有多优秀，要看他有谁指点；一个人有多成功，要看他有谁相伴，更何况“一山总比一山高”。休息放松固然重要，但需要适可而止，生命不息，奋斗不止，尤其是年轻的时候，更是如此。时间的强大是不可逆转，再繁华的都会归于尘土，与其把大把大把的时间浪费在打dota、玩三国杀或是无聊发呆上，还不如与其他优秀程序员坐在一起边喝咖啡边交流或是研究他们编写的代码，吸收他们的经验转化为自己所用。在与这些人的沟通中，学习他们解决和自己相同的任务时所使用的方法，在此过程中所学知识可能会帮你省下几个星期的时间。我们不赞成与臭棋佬下棋，棋会越下越臭的观点，但不可否认这样一个事实：和什么样的人在一起，就会有什么样的人生，和勤奋的人在一起，你不会懒惰；和积极的人在一起，你不会消沉；与智者同行，你会不同凡响；与高人为伍，你能登上巅峰。 （8）优化代码。优雅的代码非常的易读，所以如果时间允许，应该尽可能地优化代码，对时间和空间进行合理分配与使用。之前声明的一些变量，现在可能没用了。同样，并不依赖循环的一些声明可以移到循环模块之外去。否则后续开发或是技术提供会比较困难。但也需要注意，优化后的代码并不是越简短越好，用的语法越偏僻越好，因为晦涩的代码，维护成本会非常高，而且好的代码不但要实现功能，更要好维护，最好是A写的代码让B能很轻易的理解和修改。 （9）加强测试。测试的重要性并不亚于开发，所以要非常注重程序自测试。测试时，一般使用工具为主，人工为辅的策略，工具包括用单元测试，assert语句，代码测试容器，人工指用 print 和debugger 一行一行跟踪。 （10）使用输出日志。打印输出函数可以跟踪变量的执行，但频繁地插入打印会使得屏幕的输出很乱，而写一个日志函数，可以保证 Debug 的时候的输出以一种统一的，可管理的方式出现，这样在最后发布稳定版本的时候，只需要简单的几行命令就可以从代码中剔除所有的日志打印行。 （11）检查代码。代码要经常检查（包括自查和其他同事检查）。在提交代码前，找个同事一起坐下来，向他解释代码做了哪些修改。这样做的过程中通常能够发现代码中的错误，而不需要同事说一句话。这比自己审查自己的代码要有效的多。将代码的bug发现的越早，成本越低。 （12）回顾代码。在看到自己以前的代码时，通常会有两种矛盾不同的想法：第一种：我怎么写了这么烂的代码；第二种，我写的代码还是挺有成就感的。其实，经常回顾以前的代码，往往会触发新的想法，以及对以前编码更深层次的思考。 （13）编码不能想当然，任何时候都要严谨。一个简单的项目，表面上看可能可以轻松完成，其实不然，一个使用Microsoft Access的、只有3个页面的网站，最后很有可能会变成一个有30个页面并使用SQL Server作为数据库的网站。所以除非有一个类、组件或者一段已经写好的代码，并且在现有的项目已经测试通过，否则，切不可掉以轻心。 （14）任何软件都会有BUG。BUG像幽灵一样，它是永远也改不完的，所以关键是要修复严重的、影响业务的、显眼的Bug。一个软件项目，参与的人数越多，并不代表软件可靠性越好，相反，“人多手杂”，而且需求越变更，潜在的Bug会越来越多，很多时候，也许只是修改了一行代码，其很有可能影响到很多关键流程的执行。 （15） 养成耐心、冷静的好习惯。作为一名程序员，不能像普通人一样被计算机掌控，而应该作为计算机的主人，去掌控计算机。所以，一定要有足够的耐心，当程序运行不正确时，要冷静下来，站在计算机的角度去看问题、分析问题。 （16） 遵循编程规范。例如“==”与“=”的区别；合理使用缩进；使用循环和条件语句时，先把左右括号对应起来，然后再在里面写其他语句；避免使用幻数（magic numbers）；使用有意义的变量和函数名称，例如，使用‘radius’来代替圆的半径，而不是用‘r’来表示。 （17）了解底层知识。优秀的程序员不会只关注程序如何实现，而会深层次地剖析其实现机理，所以，程序员要对自己的操作系统和硬件要有足够的了解，从CPU的执行方法，到操作系统的运转，到程序的编译链接，到代码的加载与运行，到程序的调试，最后到实现的功能这一整套的内容，只有做到这样，才能真正提高。 （18）要聪明但不要“小聪明”。不反对走捷径，但是一定要论证充分，否则，可能会产生很多潜在的bug。编码中走捷径也许能够提高程序的可读性以及效率，但是如果论证不充分，不能把所有的潜在问题考虑周全，很有可能犯了丢了西瓜拣了芝麻的错误。最好的论证方法是多和他人商量，请别人检查自己的工作，将问题提早暴露。所以，不要为了做成某件事却忽略过程的连带效应，也许有一天你会为你当初的“小聪明”买单。 （19）要有创新的想法。对于大型企业而言，离开了创新，就等于失去了生命力，对于程序员个人而言，离开了创新，就等于停止了进步的脚步。虽然说天下学术全是抄，俨然一副“君不见创新项目一大堆，都被抄死化成灰”架势，但是不能因此而放弃创新，因为大地不可以因为有畜牲吃草而不复生机，山泉也不会因为有王八偷水而不冒活水。所以，无论工作有多忙，生活有多艰辛，都要尽可能地保持有一颗生机灵动的心。因为这个东西是别人偷不走的，也是最大的财富。即使暂时不具备这个东西，也要在生活中用心经营、好好培养。创新不一定要是改变全世界的大举，也不一定非得是世界上第一个做这件事的人，任何一种能改善生活的行为都可以认为是一种创新。例如写一个脚本去改变重复劳动或是采用什么方式解放自己。 （20） 对待知识要刨根问底，要有“打破沙锅问到底”的决心。“知识就像内裤，看不见却很重要”，在工作中，不能只知其然，不知其所以然，要不懈追求对细节一丝不苟的实干作风与敬业精神，而不是浮于表面，满足于填鸭，满足于考试交差或随便应付，请记住，这个世界牛逼的人少，装逼的人多，要从深层次去想其背后的思想和原理是什么。任何行业都有核心技术，掌握某一项核心技术，就可以让你进入这个行业并在其中生存，反之仅仅浅尝辄止，就会让你遭遇失败，抱怨不公。例如学会了C++面向对象程序设计，就应该弄清楚一个对象在编译后，在汇编代码中是如何被初始化的；就应该弄清楚这个对象的各个成员在内存中是如何存放的；就应该弄清楚当一个成员函数被调用时，编译器在汇编代码中加入了哪些额外的动作；就应该弄清楚虚函数的调用是如何实现的，而这些东西没有人强迫你去弄懂，只有你自己。想得多了，自己的层次才有可能提高，如果只是停留在被动的接受，那很难有所提高。 （21）尽可能复用成熟代码。如果有现成的允许使用的经过测试的代码或程序库，并且有人维护或维护成本可以接受，程序员应该尽量使用现有代码和库来节省时间和开发测试成本。 （22）多一份追求完美的执着。人是不完美的，但人们都在追求完美，程序也一样，所以程序员要去追求完美。追求完美的人更容易出色、更具责任心，做事往往也显得更专业。 （23）不要心存侥幸，可能出错的地方一定会出错，偶尔发生偶尔不发生的问题就是大问题。所以，对于一些常见的问题，一定做到防微杜渐：每个变量都做初始化；每个函数都做声明；引用每个参数都会做有效性检查；在可能出错的每个地方都会做边界条件检查等等。这样开发出来的程序一定会稳固很多，就是出错也会很容易修改。而一些没经过正规培训或是半路出家的所谓的高手，一般开发速度很快，三下两除二的就开发完成了，结果很可能出现“功能大体实现，bug总是在变”的情况，最后花费很长的时间来修改代码中的bug，总时间甚至会大大延期。而真正的高手，追求的境界是零缺陷代码。 每个人的路都在自己的脚下，自己过得怎么样，也只有自己心里明白。要想让自己的编程变得快乐有趣，还是应该努力培养一些好的习惯。也许上面的这些好习惯，要想都能在实际生活中落实并不是一件容易的事情，恐怕只有“大牛”们才能完全做到了，但只要你不断地朝着那个方向努力，相信你也会在这个努力的过程中得到长足的进步。 本文转载自 十五楼亮哥 ————-以上 自我审查， 进步 ——————–]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些简单的算法题]]></title>
    <url>%2Fblog%2F2019%2Fjs%2Fcommon%2Fjs-fontview%2F</url>
    <content type="text"><![CDATA[算法对一个程序员应该也很重要的， 毕竟需要逻辑思维的整合； 第一题题目是这样的：编写一个 function 实现一下功能 fn(1)(2)(3)() // 6 fn(1)(2)(3)…(n) // 计算乘积 . 拿到这个题的时候第一眼看到 n， 应该是要 自调用 即 【递归】。 于是 直接手撸开始… 12345678fn() &#123; const temp = [].shift.call(arguments) if (temp) &#123; fn() &#125; else &#123; ...... &#125;&#125; 堵住了 不知道怎么弄了…. 尝试 2 ：值要保存， 应该要用到闭包 12345678910111213141516const fn = (function() &#123; let num = 1; // 用来保存值 return function sub() &#123; let temp = arguments[0]; if (temp) &#123; num *= temp; // 计算当前的值 return sub; // 递归调用 &#125; else &#123; // 没有参数了 需要返回前面存储的值 // 应为这是个闭包函数， num的值是不会被销毁的 let tempNum = num; num = 1; // 重置， 否则下次调用 外层的 fn 函数 会将之前的结果集 累乘起来 return tempNum; &#125; &#125;;&#125;)(); 优化使用函数柯里化 1234567891011121314151617181920212223242526var currying = function (fn) &#123; var args = [] return function() &#123; if (arguments.length) &#123; [].push.apply(args, arguments); return arguments.callee &#125; else &#123; var arg2 = [...args]; args.length = 0; // 成功计算一次后 清除闭包中保存的数 return fn.apply(this, arg2) &#125; &#125;&#125;// 求乘积var mul = (function () &#123; return function() &#123; return [].reduce.call(arguments, (total, next, index) =&gt; &#123; return total * next &#125;, 1) &#125;&#125;)();var fn = currying(mul);fn(5)(2)() // 10 第二题查找字符串 b 是否在字符串 a 中， 前提， 不能用 slice splice subString 正则； 无非就是一个一个的寻找嘛 for 循环解决 12345678910111213141516171819202122function findStr(a, b) &#123; let aArr = a.split(""); let bArr = b.split(""); for (let key in aArr) &#123; if (aArr[key] == bArr[0]) &#123; // 找到第一个起始位置 let t = []; for (let i = 0; i &lt; bArr.length; i++) &#123; if (bArr[i] == aArr[Number(key) + i]) &#123; // 注意 字符串 + 数字 = 字符串 t.push(Number(key) + i); &#125; else &#123; break; &#125; &#125; // 如果找到就不用继续了 if (t.length == bArr.length) &#123; return key; &#125; &#125; &#125; return -1;&#125; 总结: 写代码前 先构思伪代码， 不能一上来就开始写， 容易进入误区 ~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ES6中的Proxy实现双向绑定]]></title>
    <url>%2Fblog%2F2019%2Fframe%2Fvue%2Fvue-scaffold2%2F</url>
    <content type="text"><![CDATA[摘要: 使用proxy代理实现双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p id="paragraph"&gt;&lt;/p&gt; &lt;input id="input" type="text"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* 只要更改proxyObj的属性就会触发代理事件、 1. 更改model中的数据、 2. 触发视图的更新 */ // 获取节点 var paragraph = document.getElementById("paragraph") var input = document.getElementById("input") // data数据 var data = &#123; text: 'ES6的Proxy实现双向绑定' &#125; var handler = &#123; set: function (target, prop, value) &#123; /* @&#123;arguments&#125; 1. target 用Proxy包装的目标对象 例如下文中的 data 2. props 目标对象的属性 3. value更改的值 */ if (prop === 'text') &#123; target[prop] = value; // 更新视图 paragraph.innerHTML = value input.value = value return true &#125; else &#123; return false &#125; &#125;, /* get: function(target, prop) &#123; return target[prop] || '属性不存在' &#125; */ &#125; var proxyObj = new Proxy(data, handler); // 代理data对象 input.addEventListener('input', function (event) &#123; proxyObj.text = event.target.value // 更改代理对象的属性值 &#125;, false) // 初始化 proxyObj.text = data.text; /* proxy的优势 1. Proxy可以直接监听对象而非属性 2. Proxy可以直接监听数组的变化， 而Object.defineProperty只有规定的8种方法修改才可以 3. Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。 */&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue双向绑定原理学习（2）]]></title>
    <url>%2Fblog%2F2019%2Fframe%2Fvue%2Fvue-scaffold%2F</url>
    <content type="text"><![CDATA[摘要: 手写vue双向绑定实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue原理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue_root"&gt; &lt;h3 v-text="mybox"&gt;&lt;/h3&gt; &lt;p v-text="mytext"&gt;&lt;/p&gt; &lt;input type="text" v-model="mytext"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; /* 数据响应式原理实现 1. 首先构建 Vue类、 Watcher类， 使用订阅发布者模式 2. 实现MVVM中的由 M 到 V， 把模型中的数据绑定到视图上 3. 实现由 V 到 M， 当文本框输入时或者事件触发时 【1】 更新模型中的数据， 【2】同时也更新相对应的视图 原理： vue实现数据响应式的原理利用了 Object.defineProperty()这个方法重新定义了对象获取属性值（get）和设置属性值（set）的操作来实现的 vue 3.0 是通过ES6中的 Proxy对象来实现 */ // 1. 创建 Vue 类 class Vue &#123; constructor(options) &#123; this.$options = options this.$data = options.data this.$el = document.querySelector(options.el) this._directive = &#123;&#125; // 订阅者容器 this.Observer(this.$data) // 劫持数据 this.Compile(this.$el) // 模板解析 &#125; // 劫持数据 Observer(data) &#123; for (let key in data) &#123; this._directive[key] = [] // 初始订阅者容器 存放watcher 实例 let val = data[key] let watch = this._directive[key] // this.$data中的每个属性 发生赋值时，都要更新视图 Object.defineProperty(this.$data, key, &#123; get: function () &#123; return val &#125;, set: function (newVal) &#123; // 当改变值时 更新视图 if (newVal !== val) &#123; val = newVal watch.forEach(element =&gt; &#123; element.update() &#125;); &#125; &#125; &#125;) &#125; &#125; // 模板解析 Compile(el) &#123; let nodes = el.children // 获取 子元素节点 for (let i = 0; i &lt; nodes.length; i++) &#123; let node = nodes[i] // 如果有子元素递归调用 if (node.children.length) &#123; this.Compile(node) &#125; if (node.hasAttribute('v-text')) &#123; // hasAttribute 元素拥有指定属性 let attrVal = node.getAttribute('v-text'); // 获取属性名 this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML')) // 添加订阅者 &#125; if (node.hasAttribute('v-model')) &#123; let attrVal = node.getAttribute('v-model'); // mytext this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value')) // 添加订阅者 // 绑定事件、 node.addEventListener('input', (function () &#123; return function (event) &#123; this.$data[attrVal] = node.value // event.target.value &#125; &#125;)().bind(this)) // 使用闭包的方法， 直接使用function也是可以的 &#125; &#125; &#125; &#125; // 2. 监听添加 订阅者 // 【1】. 初始化视图 // 【2】. 更新视图 class Watcher &#123; constructor(el, vm, exp, attr) &#123; this.el = el this.vm = vm this.exp = exp this.attr = attr this.update() &#125; // 更新视图 update() &#123; this.el[this.attr] = this.vm.$data[this.exp] &#125; &#125; // 创建vue实例 new Vue(&#123; el: '#vue_root', data: &#123; mytext: 'vue双向绑定原理实现', mybox: '这是一个box' &#125; &#125;)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-class类与继承]]></title>
    <url>%2Fblog%2F2019%2Fjs%2Fcommon%2Fes6-class%2F</url>
    <content type="text"><![CDATA[tips: js继承探究之class class类12345678910111213141516171819202122export class example &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; add(x, y) &#123; return x+y; &#125;&#125;export class calc extends example &#123; constructor(x,y) &#123; super(x,y); // 子类构造函数必须使用super调用父类的构造函数; this.z = x+y; &#125; mul(x,y) &#123; return x*y &#125; static div(a, b) &#123; return a / b; &#125;&#125; 类生成实例1import &#123; example, calc &#125; from '../../utils/class_example.js'; * class example类，【假装相当于是一个构造函数】 * 这个类【假构造函数】是有另外一个真的构造函数 constructor生成 * 这个类【假构造函数】中的方法其实是挂载在自身prototype上的； * * 当用new 这个类生成实例时 * var 实例myExample = new 这个类【假的构造函数】 * 实例myExample能够调用原型中(原型指的是构造函数的prototype对象)的方法，也就是这个类【假的构造函数】的prototype上的方法 * example.prototype === myExample.__proto__ // true 12345678910111213141516let myExample = new example(22, 33);console.log('myExample', myExample);console.log('example.prototype', example.prototype);//实例的原型指向构造函数的prototypeconsole.log('example.prototype === myExample.__proto__ :', example.prototype === myExample.__proto__); // true//实例的constructor指向他的构造函数 console.log('myExample.constructor === example', myExample.constructor === example); // true//实例的constructor 指向 他的构造函数prototype上的constructor console.log('myExample.constructor === example.prototype.constructor', myExample.constructor === example.prototype.constructor); //true// 类prototype上的构造函数 指向 的是 自身 console.log('example.prototype.constructor === example', example.prototype.constructor === example); // true 继承的类生成的实例1import &#123; example, calc &#125; from '../../utils/class_example.js'; 12345678910let myClass = new calc(10, 56);console.log('myClass', myClass);console.log( 'myClass.__proto__ === calc.prototype', myClass.__proto__ === calc.prototype) //trueconsole.log('calc.__proto__ === example.prototype', calc.__proto__ === example); // true 类的继承， 它的原型指向继承的那个类，而非那个类的prototype&lt;h3&gt;&lt;b&gt;3. 类上面的静态方法&lt;/b&gt;&lt;/h3&gt;import &#123; calc &#125; from '../../utils/class_example.js';let num = calc.div(100, 20);console.log('num', num); // 5]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript模块化]]></title>
    <url>%2Fblog%2F2019%2Fjs%2Fnode%2FcommonJS%2F</url>
    <content type="text"><![CDATA[tips: js模块化发展历程 commonJS模块 最早出现的javascript模块化规范 模块的引用12var math = require('math'); math.add() // 100 模块导出在node中，上下文提供了exports对象用于导出当前模块的方法或者变量，在模块中存在一个 module对象，代表模块自身，而exports是module的一个属性；将方法挂载在exports对象上作为属性即可定义导出的方式；1234567// math.jsexports.add = function() &#123; var params = 100 return params;&#125;exports.title = '导出标题' 模块标识就是传递给require的参数，比如 require(&#39;fs&#39;), require(&#39;./src/main.js) 使用CommonJS规范的js文件调用，是一个同步的过程, 本地读取require的js后，才进行后续操作 所以不适合在浏览器端执行 node模块node模块分两类 核心模块：node提供的模块； 文件模块： 用户编写的模块；node模块加载过后，会进行缓存，二次加载会优先从缓存检查； node查找文件会先在当前目录下查找 package.json, 通过JSON.parse来解析描述对象， 取出main属性指定的文件名进行定位， 如果没有package.json或者文件名错误，会默认index当做文件名； exports对象是通过形参的方式传入的， 要想实现类型class的方式引入，使用如下：1234module.exports = &#123; add: function()&#123;&#125;, title: '迂回的方式导出'&#125; NPM 安装方法 1npm install express -g 本地包安装方法只需要为NPM指明package.json文件所在的位置即可； 1npm install &lt;folder&gt; 从非官方源安装 1npm install underscore --registry=http://taobao.org 查找可require的包 1npm ls 前后端共用模块AMD规范 AMD规范是CommonJS模块规范的一个延伸；异步模块定义， 依赖前置， requirejs 定义模块1define(id?, dependencies?, factory); id和dependencies为可填项，如果不设定id，加载这个模块时，就默认使用这个模块的文件命名，否则使用id。dependencies为当前这个模块会使用到的依赖。factory是必填项，为模块的主体内容。可以是函数，也可以是对象。如果是函数，只会被执行一次。如果是对象，则是这个模块的输出值。 加载模块1require([dependencies],function()&#123;&#125;) // require(['./index.js'],function()&#123;&#125;) require()函数接收两个参数： 第一个参数是一个数组，表示所依赖的模块【要引用的模块的路径(不带.js后缀)】。 不做任何设置的默认情况下，模块的路经查找，是以当前的文件做基础 如果使用data-main属性， 模块路径查找，是以data-main指定的文件所在的路径为基础的 如果使用config方法配置了baseUrl,那么路径的查找将会以baseUrl配置的路径作为基础 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 重点：require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 使用例子123456789101112131415// 定义define('sayname',[],function()&#123; var name = 'Byron'; function sayName()&#123; console.log(name); &#125; return &#123; sayName: sayName &#125;;&#125;());// 使用require(['jquery','sayname'], function($,my)&#123; my.sayName(); &#125;); CMD规范定义方法1defin(factory); 在依赖部分，CMD支持动态引入;1234567891011// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active'); var timeout=require('...') /*依赖文件所在路径*/ timeout.init()&#125;);seajs.use(['myModule.js'], function(my)&#123; //do something&#125;); CMD是需要用到什么，才require什么，属于懒执行。AMD对待依赖的态度是预执行。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue父子组件通信与生命周期执行顺序]]></title>
    <url>%2Fblog%2F2019%2Fframe%2Fvue%2Fvue-components-life%2F</url>
    <content type="text"><![CDATA[Vue父子组件嵌套如何传值，以及生命周期的执行顺序是如何的~ 题外话： 最近变得懒惰了， 工作也不是特别忙，学习充电也没跟上，最近项目开发遇到了一些问题，记录总结下； vue框架有个优点就是，可以将.vue文件直接用作组件去使用， v-bind 属性123使 用： &lt;blog-post v-bind:likes="42"&gt;&lt;/blog-post&gt;简写方式： &lt;blog-post :title="Mytitle"&gt;&lt;/blog-post&gt;传入一个对象： &lt;blog-post v-bind="myObject"&gt;&lt;/blog-post&gt; // myObject = &#123;&#125; 在子组件中加工或者修改props props只是当做初始值， 在子组件中维护自己的状态，需要在组件的data中定义属性，并将props的值赋予即可； 123456props: ['title'],data() &#123; return &#123; childTitle: this.title &#125;&#125; props值在使用前需要进行转换，这种情况一般定义一个计算属性； 12345678props: ['dataList'],computed() &#123; fileList() &#123; return dataList.map( (item) =&gt; &#123; return item.size * 10 &#125; ) &#125;&#125; 注意： props传递数组、对象这种引用类型的数据时，改变其值将会影响父组件中的数据状态； v-on 事件事件名使用格式 事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。 因此，事件名使用kebab-case格式，使用示例： v-on=&quot;my-event&quot; 或者 @on-change=&quot;Event&quot;。 父组件监听子组件事件 即 子组件主动将数据回传父组件 或者 改变父组件的状态 父组件中绑定事件 12345678910111213&lt;!-- html --&gt;&lt;template&gt; &lt;div&gt; &lt;my-components @on-confirm="getData"&gt; &lt;/my-components&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- javascript --&gt;methods: &#123; getData(data) &#123; // do something ... &#125;&#125; 子组件使用自定义事件系统 $emit 触发事件 1this.$emit('on-confirm', myData); //触发事件，并将myData数据传递给父组件 父组件访问子组件方法、属性 vue提供了访问组件实例的方法，可以通过实例读取子组件的实例上的方法和属性； 父组件访问子组件属性或者方法12this.$refs['组件绑定的ref'].title // 访问子组件data中的属性this.$refs['组件绑定的ref'].queryList() // 访问子组件中的方法 调用子组件的方法时，我们可以巧妙的传递一个回调函数， 在子组件中将数据传回的父组件；1234567891011 // 父组件 this.$refs['组件绑定的ref'].queryList( data =&gt; &#123; // do something... &#125;) // 子组件queryList(callback) &#123; let mydata = [1, 2, 3]; if(typeof callback === 'object') &#123; callback(mydata); // 回传数据 &#125;&#125; v-if条件渲染 v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。 如果给DOM元素 或者 组件使用了v-if， 他们都会根据条件渲染，组件执行生命周期函数渲染；v-if与v-show的区别是： v-if： 组件会根据v-if进行重建和销毁； 【有更高的切换开销】 v-show：第一次就会加载渲染DOM，值变化时，只是对CSS进行了变化；【有更高的初始渲染开销】 如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 父子组件生命周期执行顺序首先 vue 中生命周期函数顺序是 **created** -&gt; **mounted** -&gt; **destroyed** 抛出问题： 页面是有若干组件组成， 组件中可能会再用组件， 业务需求是父组件获取数据后， 传递给子组件， 子组件在接到数据后，渲染在页面， 或者通过接收到的数据在进行异步请求获取数据等，那么子组件在什么阶段才能获取到父组件传递过来的props值呢？ 先来看下 父子组件的生命周期执行顺序&gt; 一般情况下父组件都是在mounted时机进行异步请求,然后才能获取到数据，显然，当父组件mounted执行时， 子组件的生命周期都已经执行完了；如果子组件需要对数据进行加工、筛选的方法在什么时机去执行呢 ？ 解决方案： 方案一、根据什么周期执行顺序， 如果我们可以在父组件的created阶段获取到数据【已经获取到】，这样在子组件的生命周期中调用方法，可以正确拿到props数据方案二、给子组件添加 v-if=”false”，等父组件在获取到数据后，设置 v-if 为 true，这时候子组件才开始进行渲染加载， 生命周期执行是可以获取props数据， 但是这样做的缺点是，异步数据获到之前，页面是空白的，因为子组件添加了 v-if=”false”, 不会渲染；方案三、子组件中使用watch来监听props的变化然后调用方法，当异步获取到数据后，watch会监听到props更新；目前该方法是比满足需求的；12345678watch: &#123; dataList: &#123; handler(newVal) &#123; this.changeData(); &#125;, immediate: true // 若使用v-if，加载子组件，watch第一次是不会被触发的，所以开启immediate为 true &#125;&#125;]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css换行与不换行]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2Fcss%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[摘要：css 实现换行与不换行 white-space 其值：normal|pre|nowrap|pre-wrap|pre-line|inherit; 属性设置如何处理元素内的空白 normal 默认,空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。 word-wrap normal|break-word; 用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。 normal: 只在允许的断字点换行(浏览器保持默认处理) break-word:在长单词或 URL 地址内部进行换行 word-break normal|break-all|keep-all; 用来标明怎么样进行单词内的断句。 normal：使用浏览器默认的换行规则。 break-all:允许再单词内换行 keep-all:只能在半角空格或连字符处换行 省略号显示超出文本1234text-overflow: ellipsis;overflow: hidden;white-space: nowrap;width: 160px; .main_code { width: 400px; border: 2px solid lightgreen; display: flex; flex-direction: column; } .main_code .wrap-line { display: flex; margin-bottom: 5px; } .main_code .title { width: 150px; flex-shrink: 0; text-align: right; /* color: red; */ } .main2 { width: 400px; border: 2px solid lightsalmon; display: flex; flex-direction: column; } .main2 .wrap-line { display: flex; margin-bottom: 5px; } .main2 .title { width: 150px; flex-shrink: 0; text-align: right; /* color: red; */ } .main2 .a-content, .main2 .d-content, .main2 .b-content { white-space: nowrap; } .main2 .aa-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .main3 { margin-top: 5px; width: 400px; border: 3px solid rgb(235, 24, 154); display: flex; flex-direction: column; } .main3 .wrap-line { display: flex; margin-bottom: 5px; } .main3 .title { width: 150px; flex-shrink: 0; text-align: right; /* color: red; */ } .main3 .c-content, .main3 .e-content { word-break: break-all; } .last-content li{ line-height: 2em; } 默认情况下： 我们发现连续数字和连续字母不进行换行，而是会撑破盒子； 默认情况【中文】： 我是一段很长的 文字我是一段很长 的文字我是一段很长的文字 有空格的英文： When did I say we could run through the rain and not get wet? 连续英文： WhendidIsaywecouldrunthroughtherainandnotgetwet? 有空格的数字： 123456789456123 4567 8945612 345678 94123 连续数子： 1234567894561234567894561234567894123 强制不换行方法： 12345678div &#123; white-space:nowrap;&#125;div &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 中文： 我是一段很长的 文字我是一段很长的文字我是一段很长的文字 中文： 我是一段很长的 文字我是一段很长的文字我是一段很长的文字 有空格的英文： When did I say we could run through the rain and not get wet? 有空格的数字： 123456789456123 4567 8945612 345678 94123 强制换行方法：123div &#123; word-break: break-all;&#125; *注意：设置强制将英文单词断行，需要将行内元素设置为块级元素。 连续英文： WhendidIsaywecouldrunthroughtherainandnotgetwet? 连续数子： 1234567894561234567894561234567894123]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url收藏夹]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2FremberUrl%2F</url>
    <content type="text"><![CDATA[摘要: 记录一些学习、工具网站 在线图片压缩网站 KOA小书]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发总结(二)]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fwe_chat%2Fwechat-003%2F</url>
    <content type="text"><![CDATA[内容：小程序转发、小程序组件使用 小程序转发微信小程序当页面js中有onShareAppMessage函数，右上角就会有转发按钮， 默认转发的当前页面；转发时的图片就是当前页面80%的高度；官方APIonShareAppMessage123456789101112131415161718192021222324/*** 用户点击右上角分享*/ onShareAppMessage: function (ops) &#123; if (ops.from === 'button') &#123; // button：页面内转发按钮； // menu：右上角转发菜单 console.log(ops.target) &#125; return &#123; title: '我的小程序', path: 'pages/index/index', //转发链接打开的页面 imageUrl: 'img/自定义图片路径', //没有时使用当前页面内容 // 转发成功 success: function (res) &#123; console.log("转发成功:" , res); &#125;, // 转发失败 fail: function (res) &#123; console.log("转发失败:" ,res); &#125; &#125; &#125; 转发成功后，小程序会自动显示一个 tips 转发成功 ； 小程序组件使用父页面使用组件， 传递两个属性， propMydata 、myTitle 1234&lt;my-component prop-mydata="&#123;&#123;mydata&#125;&#125;" my-title="&#123;&#123;mytitle&#125;&#125;"&gt;&lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/my-component&gt; 123456Page(&#123; data: &#123; mydata: [1,2.3,4], mytitle: 'this is a props' &#125;,&#125;) 组件页面接收props1234567&lt;view&gt; &lt;my-component prop-mydata="&#123;&#123;mydata&#125;&#125;" prop-title="&#123;&#123;mytitle&#125;&#125;"&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/my-component&gt; &lt;view&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt;&lt;/view&gt; 1234567891011121314151617// 组件jsComponent(&#123; /** * 组件的属性列表 */ properties: &#123; propMydata: &#123; //props名字 type: Array, //类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） // value: &#123;&#125;, //属性初始值（可选），如果未指定则会根据类型选择一个 observer: function(newVal, oldVal, changedPath) &#123; // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange' // 通常 newVal 就是新设置的数据， oldVal 是旧数据 &#125; &#125;, propTitle: String &#125;,&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview使用总结（二）]]></title>
    <url>%2Fblog%2F2018%2Fframe%2Fvue%2Fvue-ivu-001%2F</url>
    <content type="text"><![CDATA[摘要: iview表单校验、vue中实现hover效果、vue Render方法使用姿势 iview表单校验1. iview在校验select报错 问题：即使选择了某一项一直报错？; 原因: iview默认校验数据类型为String, 而我们再给select的 :value是number类型的;解决方法: 加入 type: ‘number’ 1234industryType: [ &#123; required: true, message: "请选择", trigger: "change", type: 'number' &#125;] 2. 多条件校验， 正则校验12345 contractPhone: [ &#123; required: true, message: "请输入联系电话", trigger: "blur" &#125;, &#123; type: 'string',pattern: /^1\d&#123;10&#125;$/, message: '联系电话格式有误', trigger: "blur" &#125; // 使用正则表达式] 3.自定义方法校验 1234567891011121314provinceArr: [ &#123; validator: this.proviinceValidate, // 调用自定义方法 支持异步，比如查重 required: true, trigger: "change" &#125;]proviinceValidate(rule, value, callback) &#123; if (Array.isArray(value) &amp;&amp; value.length === 2) &#123; return callback(); // 返回成功校验 &#125; else &#123; return callback(new Error("地址不能为空")); // 返回失败校验 &#125;&#125; 4. 校验日期，或者城市选择器 问题： iview默认校验的数据类型是 String，所以用默认校验，type是不符合的。 解决： type：data123province:[ &#123; required: true, message: '预送达时间不能为空', trigger: 'change' ,type: 'date'&#125;,], vue中实现hover效果12345&lt;div class="img-wrap-item" @mouseenter="showCloseIcon(item)" @mouseleave="showCloseIcon(item)"&lt;/div&gt; iview select remote模式下，无法清空搜索输入的内容当使用remote模式下的select弹窗时， 关闭再显示，无法清空其内容 123456789&lt;Select class="change-select" v-model="concatCustomer" filterable remote :remote-method="queryCustomerList" :loading="customer_loading" placeholder="请输入客户名称"&gt; 解决方法： document.querySelector(&#39;.change-select .ivu-select-input&#39;).value = &#39;&#39; vue Render方法使用姿势 官方使用文档iview框架中使用render函数方法：render:(h,params)=&gt;{}render参数123render:(h, params) =&gt; &#123; return h(" 定义的元素 "，&#123; 元素的性质 &#125;，" 元素的内容"/[元素的内容])&#125; 简单例子1234567891011121314151617181920212223242526272829303132333435render: (h, params) =&gt; &#123; return h('p', &#123; props: &#123; // 组件peops &#125;, style: &#123; // style样式属性 height: '60px', border: "1px solid lightblue" &#125;, domProps: &#123; // dom原生属性 href: 'javascript:void(0);', &#125;, on: &#123; // 绑定 vue事件 &#125;, nativeOn: &#123; // 绑定原生事件 click: value =&gt; &#123; this.$Message.success('点击事件成功啦') &#125;, keydown: event =&gt; &#123; console.log('event.target.value', event.target.value); &#125; &#125; &#125;, [h('span', &#123; style: &#123; background: 'lightgreen' &#125; &#125;, 55), [h('a',&#123; style: &#123; border: '1px solid red' &#125; &#125;, '我是a标签')] ], ) &#125; 完整iview表单校验、验证、清空方法html -&gt; template123456789101112131415161718192021222324252627&lt;Form :model="formItem" ref="formItem" :rules="formValidate" inline :label-width="84"&gt; &lt;!-- label-width作用于 所有的子formitem inline行内模式 --&gt; &lt;FormItem label="联系电话" prop="contractPhone"&gt; &lt;Input v-model="formItem.contractPhone" style="width: 280px;" placeholder="请输入联系电话" /&gt; &lt;/FormItem&gt; &lt;FormItem label="公司所在地" prop="provinceArr"&gt; &lt;!-- 此处需要用 prop 名字要与v-model的 一致 --&gt; &lt;Cascader v-model="formItem.provinceArr" :data="provinceList" trigger="hover" &gt;&lt;/Cascader&gt; &lt;/FormItem&gt; &lt;FormItem label="请选择" prop="select"&gt; &lt;Select v-model="formItem.industryType" &gt; &lt;Option v-for="item in categoryList" :key="item.value" :value="item.value" &gt;&#123;&#123; item.label &#125;&#125;&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt;&lt;/Form&gt; data中的校验：1234567891011121314151617181920212223242526272829303132333435363738394041424344data() &#123; return &#123; formValidate: &#123; // 多重校验 contractPhone: [ &#123; required: true, message: "请输入联系电话", trigger: "blur" &#125;, &#123; pattern: /^1\d&#123;10&#125;$/, message: '联系电话格式有误', trigger: "blur" &#125; // 使用正则表达式 ], industryType: [ &#123; required: true, message: "请选择行业类别", trigger: "change", type:'number'&#125; ], // 自定义校验 地址控件校验 provinceArr: [ &#123; validator: this.proviinceValidate, // 调用自定义方法 支持异步，比如查重 required: true, trigger: "change" &#125; ] &#125; &#125;&#125;,method: &#123; // 异步或者自定义校验方法 proviinceValidate(rule, value, callback) &#123; if (Array.isArray(value) &amp;&amp; value.length === 2) &#123; return callback(); &#125; else &#123; return callback(new Error("地址不能为空")); &#125; &#125;, // 表单提交 验证方法 submit() &#123; this.$refs['formItem'].validate( async (valid) =&gt; &#123; // 如果有await异步操作 需要async if (valid) &#123; // 校验通过 &#125; &#125;), // 清空方法 clear() &#123; this.$refs['formItem'].resetFields() &#125;&#125;]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>iview组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序跳转总结]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fwe_chat%2Fwechat-002%2F</url>
    <content type="text"><![CDATA[简介: 总结微信小程序开发过程中如何正确使用跳转 小程序跳转问题官方地址传送门 wx.navigateBack 小程序返回上一页或者多级页面。可以使用 getCurrentPages() 获取当前的页面栈，决定需要返回几层。 123wx.navigateBack(&#123; delta: 2 // 返回上一页 层级&#125;) wx.navigateTo() 可以传参 wx.navigateTo(OBJECT) 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面跳转的页面会自带返回按钮 12345678910wx.navigateTo(&#123; url: 'test?id=1'&#125;)// test.jsPage(&#123; onLoad(option) &#123; console.log(option.query) &#125;&#125;) wx.reLaunch()可以传递参数 关闭所有页面，打开到应用内的某个页面跳转的页面不会有返回按钮 wx.switchTab()不能带参数 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面跳转的页面不会有返回按钮 wx.redirectTo() 可以传递参数 关闭当前页面，跳转到应用内的某个页面。 123wx.redirectTo(&#123; url: 'test?id=1'&#125;) 案例问题？ 页面A-【navigateTo】 -&gt; login页面-【navigateTo】 -&gt; 页面C（该页面需要登录，所以在A跳转的时候判断是否登录，如未登录跳转到登录页面）开始时跳转都用的是 navigateTo, 在页面C中点击返回时，返回到了登录页，这显然是错误的，一直在想如何从C页面直接跳回A页面…. 解决方法： 在login页面使用 wx.redirectTo 预期效果：A -&gt; login -&gt; C 然后 C直接返回A A -&gt; login 通过 wx.navigateTo 跳转 login -&gt; C 通过 wx.redirectTo 跳转.跳转触发后 login 页面就会被销毁， C 页面再返回 wx.navigateBack 就会直接到 A 了]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018下半年学习资料整理&学习计划[11]]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2Fstudy2018-05%2F</url>
    <content type="text"><![CDATA[每天收集一点，每天学习一点 JavaScript 深入理解javascript原型和闭包]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端储存的种类与方法]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2Fwebstorage%2F</url>
    <content type="text"><![CDATA[摘要： localStorage、sessionStorage、cookie的用法以及区别 localStorage的优势与用法 localStorage拓展了cookie的4K限制 localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的; localStorage的局限1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换3、localStorage在浏览器的隐私模式下面是不可读取的4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡5、localStorage不能被爬虫抓取到 localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空 localStorage的写入方法var storage = window.localStorage 方法一： storage[&apos;name&apos;] = &apos;dale&apos; //写入name字段 方法二： storage.info = &apos;this is a info&apos; // 写入info字段 方法三： storage.setItem(&quot;age&quot;, 18) // 写入info字段 localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage localStorage的读取方法 方法一: var name = storage.name console.log(name); // &apos;dale&apos; 方法二： var info = storage[&apos;info&apos;] console.log(info) // &apos;this is a info&apos; 方法三： var age = storage.getItem(&apos;age&apos;) console.log(age) // &apos;18&apos; 注意这里输出的18是String类型的 localStorage只支持string类型的存储。 localStorage的删除方法 storage.removeItem(‘name’) // 删除key为name的键值 localStorage的清空方法 storage.clear() //清除所有的storage sessionStorage的用法sessionStorage的使用方法与localStorage完全相同，唯一的区别是：sessionStorage当会话结束的时候，sessionStorage中的键值对会被清空;详解： 当 当前tab关闭，或者浏览器关闭；sessionStorage会被清空； 复制tab标签时，sessionStorage会被复制， 重新打开相同域名时tab时，sessionStorage是不会被共享的 cookie概念和使用方法cookie的基本概念 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 有效期设置：Max-Age 安全secure=true是只在ssl或者https安全协议下传输 HttpOnly=true时，禁止通过js脚本获取cookie；防止xss攻击 每个域名下的cookie 的大小最大为4KB，最多20个 cookie的使用cookie的设置1234567function setCookie(cname,cvalue,exdays) &#123; var SetTime = new Date(); //设置过期时间 SetTime.setTime(SetTime.getTime()+(exdays*24*60*60*1000)); //设置过期时间 var expires = "expires="+SetTime.toGMTString(); //设置过期时间 document.cookie = cname + "=" + cvalue + "; " + expires; //创建一个cookie &#125; cookie的读取123456789101112131415function getCookie(c_name)&#123;if (document.cookie.length&gt;0) &#123;c_start=document.cookie.indexOf(c_name + "=")if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(";",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125;return ""&#125; cookie的删除将cookie的有效时间改成昨天。 总结共同点： 共同点：都是保存在浏览器端、且同源的 区别 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localstorage在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在 cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在 本文参考链接： 关于Cookie、session和Web Storage]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发采坑指南（一）]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fwe_chat%2Fwechat-001%2F</url>
    <content type="text"><![CDATA[tips: 小程序背景图使用、动态图片、触发事件， iconfont使用 block标签&lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 例如 wx:if wx:for 1234&lt;block wx:if="&#123;&#123;true&#125;&#125;"&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; 小程序中的背景图片实现背景图的方法 tips： background-image 只能用网络url或者base64 . 本地图片要用image标签才行。 可以通过image标签和其他元素层叠来实现背景图，使用 position：absolute定位层叠； 小技巧：实现如图效果：采用元素溢出，和position:relative定位来实现 html 12345&lt;view class='wrap-center-line'&gt; &lt;view class='line-bac'&gt; &lt;text class='line-bac-text'&gt;车次详情&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; css 1234567891011121314151617181920.wrap-center-line &#123; height: 40rpx; padding: 12rpx 32rpx; display: flex; align-items: center;&#125;.wrap-center-line .line-bac &#123; width: 100%; height: 2rpx; border-top: 2rpx dashed #d9d9d9; text-align: center;&#125;.wrap-center-line .line-bac-text &#123; display: inline-block; position: relative; top: -24rpx; background: #fff; color:#A6A6A6; padding: 0 24rpx;&#125; 动态图片显示动态改变图片，可以在url中使用双括号的方式来绑定数据 &lt;image class=&quot;swiper-img&quot; mode=&apos;aspectFill&apos; src=&apos;../../assets/swiper/{{item}}&apos;&gt;&lt;/image&gt; 触发事件传值在view层绑定事件，将当前视图对应的数据传递到事件中去，方法如下 1&lt;view bindtab="&#123;&#123; clickHandle &#125;&#125;" data-batchNumber='&#123;&#123;batchNumber&#125;&#125;'&gt; 点击按钮 &lt;/view&gt; 在js事件中接收时data-batchNumber N会默认转换成小写字母 1234567clickHandle: function(event) &#123; //假定batchNumber的值是 P132456789 console.log(event.currentTarget.dataset) // 输出的是 &#123; batchnumber: 'P123456789' &#125; 注意到： 其中的 n 是小写的 // 应该如下方法获取 let &#123; batchnumber &#125; = event.currentTarget.dataset&#125; 小程序使用iconfont小程序中使用iconfont其实和PC上一样，只需要将从iconfont上下载下来的 iconfont.css 文件的后缀修改成 iconfont.wxss 将iconfont.wxss文件放在小程序根目录下，在 app.wxss 中引入 @import &quot;icon-font.wxss&quot;; 页面使用： &lt;text class=&#39;iconfont icon-ic_dianhua&#39;&gt;&lt;/text&gt;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九月读到的一些好文章]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2Fseptember%2F</url>
    <content type="text"><![CDATA[tips: september vue移动端适配 + mint-ui 原生JS实现轮播图–第二章动画实现 vue与react的区别 彻底搞懂word-break、word-wrap、white-space 富文本编辑器 wangEditor VUE vuex源码解读-大搜车]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dos下批处理命令bat]]></title>
    <url>%2Fblog%2F2018%2Fothers%2Fbat001%2F</url>
    <content type="text"><![CDATA[tips: 一键操作的批处理命令，重复的事情交给电脑~~ 前言 在我们开发过程中，经常会遇到切换环境，重启nginx，或者执行一系列的dos命令等，频繁的操作势必会很繁琐，浪费时间，作为一个程序员，重复的事情，当然要交给电脑了~ 首先了解一下什么是 .bat ？ 批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理。批处理文件的扩展名为bat; 正文开始以一个简单的nginx启动、重启、停止说起：1. 首先切换到nginx目录，包含nginx.exe目录； 2. 按住shift，鼠标右键在此处打开powershell窗口； nginx一般的三个操作如下： 描述 命令 启动 start .\nginx.exe 重启 .\nginx.exe -s reload 停止 .\nginx.exe -s stop 注意：如果你不小心启动了多次，那么就会启动多个nginx进程，你用stop不能全部停止；可以用如下命令： taskkill /fi &quot;imagename eq nginx.EXE&quot; /f 杀掉所有的nginx进程； 接下来就展示如何使用bat批处理命令来做这个事情，先看下代码： 1234567891011121314151617181920212223242526272829303132333435363738@echo off:entryclsecho nginx一键操作命令集合：echo ********************************echo 1. 开启nginxecho 2. 重启nginxecho 3. 停止nginxecho 4. 退出echo ********************************echo 请选择你要执行的操作...set /p userchoice=if "%userchoice%"=="1" goto startNif "%userchoice%"=="2" goto reloadNif "%userchoice%"=="3" goto stopNif "%userchoice%"=="4" goto quit:startNstart .\nginx.exegoto succ:reloadN.\nginx.exe -s reloadgoto succ:stopNtaskkill /fi "imagename eq nginx.EXE" /fgoto succ:quitexit:succecho 执行成功pausegoto entry@echo on 首先在上面说到的nginx目录下，新建一个.bat文件，将上述代码放进去就可以体会到一键操作了； 接下来大概说说代码set /p userchoice=，意思是设置一个变量userchoice，值为用户输入；:startN :entry :succ类似一个方法，判断用输入的值，执行对应的方法；批处理命令是一行一行的执行命令，执行完成后，就会关闭shell窗口，如果想保持可以使用 pause 会出现请按任意键继续…；如此就完成了一个一键操作的脚本，由于该文件放在nginx的安装目录，为了方便，可以右键，发送快捷模式到桌面； bat进阶-修改文件 由于目前本地的项目是用nginx启动访问，至于为什么，这里不解释，就是必须要用nginx，nginx里面的转发需要调用后台接口，而调用的环境经常变化，这样就需要先修改代理接口环境地址，然后重启nginx； 现在我们的bat要执行修改文件，然后重启nginx操作，代码如下（仅供参考）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@echo off:entryclsecho *****系统一键切换环境*****echo ********************************echo 1. 开发dev01环境echo 2. 开发dev02环境echo 3. ---测试--01--环境echo 4. ---测试--02--环境echo ********************************echo 请选择你要切换环境...set /p userInput=if "%userInput%"=="1" goto dev01if "%userInput%"=="2" goto dev02if "%userInput%"=="3" goto test01if "%userInput%"=="4" goto test02:dev01set cc=proxy_pass http://ys.dev01.51ju.cn; #taggoto switch:dev02set cc=proxy_pass http://ys.dev02.51ju.cn; #taggoto switch:test01set cc=proxy_pass http://ys.test.51ju.cn; #taggoto switch:test02set cc=proxy_pass http://ys.test02.51ju.cn; #taggoto switch:switchecho 正在切换中...echo -------------------------(for /f "tokens=*" %%i in (a.conf) do echo %%i|findstr /ie tag&gt;nul&amp;&amp;echo %cc%||echo %%i)&gt;temp.inimove /y temp.ini a.confecho -------------------------echo 已经切换至： %cc%echo -------------------------echo 开始重启nginx...cd ../../.\nginx.exe -s reloadecho --------------------------echo nginx 重启成功~cd D:\nginx-1.13.12\conf\servers\echo --------------------------pausegoto entry@echo on 大概原理同上，主要说明一下for循环这个语句， 首先获取到a.conf,然后循环每一行代码， %%i相当于循环的当前行代码， |findstr是在当前行查找字符串， /ie忽略大小写和从行末开始查找； tag&gt;nul找到&#39;tag&#39;时，就把这一行清空： echo %cc%是将方法中设置的cc值复制到这一行； move -y就是移动文件到当前目录并取消重写文件发出的提示； 注意： 默认配置中，需要修改的那一行命令需要添加一个标记tag。 以上就完成了对一个文件的修改；修改文件后，需要重启nginx，但是这个文件的目录和nginx不在同一个目录下，需要执行命令cd ../../跳转到nginx.exe的那个目录,执行nginx重启，由于切换命令要重复使用，当前目录已经修改了，所以需要再跳转回来cd D:\nginx-1.13.12\conf\servers\; 娱乐一下相信看过科幻片的同学都知道，电脑大神或者黑客操作电脑时，不断的弹出dos窗口，然后绿色代码滚屏，其实很简单实现，原理如下：123456789@echo offecho 当前在call目录下start "reload" cmd /kcd /d D:\test call reload.bat echo over...pause 以上是在当前脚本中，新开dos窗口并调用其他目录下的脚本，如此循环重复，很简单的就实现不断开dos窗口了，至于滚屏，结合echo输出就可实现，pause命令是，代码执行到这一行时，提示请按任意键继续… 然后继续执行命令； ps: 第一次捣鼓bat，如有错误，欢迎指出，共同进步； 参考链接： 批处理—findstr命令详解 DOS shell bat 输入输出变量 cmd - 如何在bat文件中调用另一个bat文件]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>批处理命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则基础属性手册]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2Fregexp%2F</url>
    <content type="text"><![CDATA[摘要: 一堆的符号加字符数字是如何进行匹配的呢~~本文同步于掘金平台 https://juejin.im/post/5d29727d518825187f2970e1 前端开发中，经常用到正则表达式来对表单或者一些数据进行校验，在此总结正则使用的基础知识，以及一些工作中常用的正则表达式· 正则基础知识正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 创建正则表达式 通过字面量创建 var reg = /\bis\b/g –&gt;正则表达式对象 /g表示全局匹配，否则只匹配第一个/b单词边界，后面详细说明 12var str = 'this is a dog is!'str.replace(reg,'IS') // 输出："this IS a dog Is!" 通过构造函数创建 var reg = new RegExp(/\bis\b/g) –&gt;正则表达式对象 12var str = 'this is a regexp'reg.test(str) // 返回true，字符串中包含 is 修饰符 @ @ @ g global 全文进行搜索匹配； 默认false，匹配到第一个时停止 i ignoreCass 忽略大小写，默认false，对大小写敏感 m multiline 默认false，多行搜索 lastIndex - 是当前匹配内容的的最后一个字符的下一个位置 source - 正则表达式的文本字符串 元字符 @ @ \t 水平制表符table \v 垂直制表符 \n 换行符 \r 回车符 \0 空字符 \f 换页符 \cX ctrl +x 字符类 @ @ [] 元字符，来构建一个简单得类 [abc] 字符只能包含abc中的一种或者多种 ^abc 字符类取反,非a或b或c的内容 范围类 @ @ [0-9] 匹配1=0到9的数字 [a-zA-Z] 匹配大小写字母 [a-zA-Z-] 匹配大小写字母与- 预定义类 @ @ @ . [^\r\n] 除了回车符和换行符之外的所有字符 \d [[0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 \S [^\t\n\x0B\f\r] 非空白符 \w [a-zA-Z_0-9] 单词字符(字母、数字下划线) \W [^a-zA-Z_0-9] 非单词字符 边界字符 @ @ ^ 以xxx开始 $ 以xxx结束 \b 单词边界 \B 非单词边界 量词 @ @ ? 出现0次或一次 (最多出现一次) + 出现一次或者多次(至少一次) * 出现0次或者多次(任意次) {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 贪婪模式123var str = '123456789'str.replace(/\d&#123;2,8&#125;/,'X') // 输出 X9// 按照最大的匹配，尽可能多的匹配 非贪婪模式 在量词后面加上 ? 123var str = '12345678'str.replace(/\d&#123;3,6&#125;?/,'X') // 输出 XX78// 尝试最小可能123、456的匹配 分组 捕获(x) 分组 – 捕获括号匹配到字符串后会记住字符串，替换环节可以用 $1 $2 ... $n方法使用；123var str = '2018-09-01'str.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g,'$3-$2-$1')//输出： '01-09-2018' (?:x) 非捕获分组匹配X，但是不记住X， 使得能够定义为与正则表达式运算符一起使用的子表达式12var reg = /(?:foo)&#123;1,2&#125;/// 如果表达式是 /foo&#123;1,2&#125;/，&#123;1,2&#125;将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则&#123;1,2&#125;会匹配整个 ‘foo’ 单词。 或| 或1234var str = 'green Apple and red Apple';var reg = /green|red/g;str.replace(reg, 'yellow');// "yellow Apple and yellow Apple" 前瞻 前瞻: 就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾、后瞻方向相反—js不支持后顾 reg匹配后，检查assert是否符合正向前瞻 reg(?=assert) 符合断言负向前瞻 reg(?!assert) 不符合这个断言example1:1234var str = 'a2*3'str.replace(/\w(?=\d)/g,'X')// 输出：'X2*3'// 匹配单词字符并且后面是数字 example2:1234var str = 'Hello, Hi, I am Hilary.';var reg = /H(?=i)/g;var newStr = str.replace(reg, "T");//输出： Hello, Ti, I am Tilary. 一个强大的正则可视化工具工具传送门： RegExper效果如下：这样的正则表达式是不是清晰多了~~~ 后记正则表达式基础属性大概就这多了，下一节将继续分析正则表达式的对象属性~~ 补充知识关于正则表达式\1 \2之类的问题 第一个 12var RegExp = /^(123)(456)\2\1$/;// 匹配的字符串是 123456456123 第二正则表达式 12var RegExp1 = /^(123)(456)\1$/;// 匹配到的字符串是 123456123 第三正则表达式 12var RegExp1 = /^(123)(456)\2$/;// 匹配到的字符串是 123456456 这个\1 \2…… 都要和正则表达式集合()一起使用 简单的说就是 \1表示重复正则第一个圆括号内匹配到的内容 \2表示重复正则第二个圆括号内匹配到的内容]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端联调工具之-Fiddler]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2Ffiddle001%2F</url>
    <content type="text"><![CDATA[tips: 开发必备调试工具-fiddler 前言 现在的大型项目基本前后端分离；前端不仅仅只是负责界面，交互了；需要做的工作越来越多，但是都离不开和各个部门的沟通协作，这样才能高效率；最为密切的就是后端了，今天就简单的分享下在项目实战过程中用到的利器–fiddle工具； 不就是 fiddle 嘛，抓包工具嘛，NO,NO,NO…… Fiddler 是最强大最好用的 Web 调试工具之一，它能记录所有客户端和服务器的 http 和 https 请求，允许你监视，设置断点，甚至修改输入输出数据，Fiddler 包含了一个强大的基于事件脚本的子系统，并且能使用.net 语言进行扩展 你对 HTTP 协议越了解， 你就能越掌握 Fiddler 的使用方法. 你越使用 Fiddler,就越能帮助你了解 HTTP 协议. 轻描淡写-介绍下 fiddle先贴一个官网地址：fiddle 官网至于怎么形容他： The free web debugging proxy for any browser, system or platform抓包、调试、代理、各种很强大的功能 不费话了，开始干活下载，一路 next 就可以安装好；ok，将看到这个界面 左边列表就是捕获到的所有请求，不妨随便百度一下，就能看到你百度的请求； 这个是我点击百度搜索框，触发的请求，右边webform中可以看到这个请求的内容，下边的JSON是服务器返回的内容；很清晰，一目了然。 fiddler 工具的基本使用可以参考官网文档或者慕课网有视频教程； fiddler 的厉害之处To 测试妹子对于测试来说，如上所示，分析请求，定位是前端还是后端的问题，检验界面与数据是否一致，有时候出现神奇问题，要么是逻辑问题，要么是界面和数据不一致造成的，精准定位问题，精准发锅； To 大前端fiddler 不只是具有简单的抓包功能，在他的社区有很多的插件，使他的能力发挥到极致；详细介绍下项目中常常使用的一个神器 Willow--Fiddler的插件，提供重定向和host主机等功能,三秒钟解决联调、跨域问题，没错就是三秒.贴一个下载地址：fiddler2 + willow 下载 密码：o3lgfiddler4 + willow 下载 密码：kf8p安装fiddler后安装插件 willow,willow 如果安装失败，请尝试右键使用 管理员身份打开；安装好后会在右边看到一个绿色的小图标，ok，点击他； 核心内容 问题现状：我们的项目通常开发时都跑在本地服务下，一般是127.0.0.1:8080,如果我们希望本地代码的服务能够正常访问后端，或者访问到测试机的真实数据，这就跨域了，因为本地和后端或者测试的都不在一个域名下，是无法访问到数据的，通常的做法是启动一个 Nginx 服务来进行转发，这一个过程很麻烦，配置改来改去，而且如果要做到，代码修改实时看到效果，那就更复杂了。。。 解决方案： 我的做法是： 将本地服务127.0.0.1代理到某个域名比如www.cloud.com,这时候访问这个域名就能看到自己的项目了，这个域名下也是木有后端或者测试机的接口的，怎么办了，继续代理转发，将域名下所有的接口代理到真实的 IP 下，比如后端或者测试机接口的服务在 10.50.12.24:8088下，那我们就将www.cloud.com/order[order 是后端接口固定的项目名，每个接口都在这个目录下]指向10.50.12.24:8088下，完美解决； 顺着这个思路 3 步解决， 在 willow 中添加项目快捷键ctrl+p； 添加 host 代理ctrl + o; 添加指向 add exten ctrl + n;不懂的童鞋看图 图一：图二：好了可以开心的联调代码了；ps： 这个 checkbox 框框表示是否启用，如果想去掉，点掉就好了；比手动去修改 host 方便多了； To 后端后端大侠有时候想这么干，用测试机的前端代码，来访问自己本地的服务，这样就不用浪费前端童鞋的资源了，测试机上自己测试；这个步奏其实就是上面的逆过程，简单多了，测试机的前端代码自然指向测试机的后端代码，使用上面思路的第三步；添加指向，指向本机，这里要注意两个点： 直接代理接口www.cloud.com/order –&gt; 本地服务+端口 如果是 https 的，需要后端给 tomcat 配置 https 证书 介绍就先到这里了，更多使用技巧，后续在更新。。。 后记后端某个功能 bug，不断地让前端点击按钮发请求，他来打断点，有时候我比较懒，就让后端自己点，后端如何访问前端开发机电脑上的代码，来访问自己电脑上的后端服务？这个问题大家可以思考下，下期分享。。。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue原理学习笔记（一）]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2Fvuestudy01%2F</url>
    <content type="text"><![CDATA[Vue响应式原理-将date数据变成可观察的（observable） 学习笔记- 第一步、将date数据变成可观察的（observable）; 怎么实现了，主要是利用的对象的 defineProperty属性！ 12345678910111213141516171819202122232425262728293031323334353637383940// 遍历对象，将对象的每个属性变成可观察的function observe(data, callback) &#123; Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key], callback) &#125;)&#125;function defineReactive(obj, key, data[key], callback) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, //属性的可枚举性，for in是否能够遍历到 configurable: true, // 表示能否通过delete删除属性从而重新定义属性 get: function() &#123; // 第一次执行`render`的时候进行收集，详见下一章 &#125;, set: function(newVal) &#123; callback() //回调执行render刷新视图 &#125; &#125;)&#125;calss Vue &#123; // 创建vue实例时将options中data指向了vue的实例， 即在VM实例上挂在了一个 `_data`属性; // 初始化调用了observe constructor(options) &#123; this._data = options.data; // this指向实例 observe(this._data, options.render) &#125;&#125;let app = new Vue(&#123; el: '#app', data: &#123; text1: '1', text2: '2', &#125;, render() &#123; console.log('render') &#125;&#125;) 上面的方法就简单的实现了将vue里面的data数据变成可观察的模式；如果改变了data里面属性的值就会触发对象的set， 从而触发订阅者的回调函数（如刷新视图）]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识地图]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2FfontknownageMap%2F</url>
    <content type="text"><![CDATA[分类整理前端开发的一些知识点 浏览器缓存（http缓存） 面试精选之http缓存 这一次,让我们再深入一点 - HTTP概述 面试 – 网络 HTTP 网站性能优化 web前端性能优化-3方面 网站性能优化实践总结 移动端开发 移动端常见bug汇总001 touchstart与click不得不说的故事 移动端滚动穿透解决方案 H5手机端开发问题汇总及解决方案 VUE专场 Vue 面试中常问知识点整理 JavaScript之实现一个简单的Vue vue与react的区别 Vue 项目里戳中你痛点的问题及解决办法 Promise Promise实现原理（附源码） Promise 迷你书 理解 Promise 的工作原理 Node.js最新技术栈之Promise篇 ES6 通过示例来学习ES2016, 2017, 2018的新特性 webpack学习 webpack小书 webpack【gitbook】 面试经验 . 总结了17年初到18年初百场前端面试的面试经验-含答案 从输入URL到页面加载的过程 一些基础的前端技术面试问题 2017年前端面试题整理汇总100题 最全前端开发面试问题及答案整理 缓存详解 雅虎前端优化的35条军规 - 咸鱼老弟 - 博客园 记一次凉凉的小米面试 近百高频知识点，十万余字，地表最强前端面试图谱了解下 不要再问我跨域的问题了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018上半年学习资料整理&学习计划[7]]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2Fstudy2014-07%2F</url>
    <content type="text"><![CDATA[七月 学习博客 王海燕的博客 vue学习 滴滴前端学习课程 vue2.0源码学习 在线工具 在线工具 掘金2018上半年整理 2018上半年掘金微信群日报优质文章合集：前端篇 Nginx跨域配置 Nginx通过CORS实现跨域 vue的坑 Vue 项目里戳中你痛点的问题及解决办法 小程序 一个json帮你完成分享朋友圈图片 #### 通过示例来学习ES2016, 2017, 2018的新特性]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非大型网站的SEO优化之路]]></title>
    <url>%2Fblog%2F2018%2Fothers%2Fseo%2F</url>
    <content type="text"><![CDATA[网站常用的SEO优化方式 简介 SEO 搜索引擎优化 免费 SEM 搜索引擎营销 收费 SEO排名机制 搜索引擎蜘蛛 权重 权重提升SEO优化重要的三要素 标题 关键词 描述 外链 -&gt; 分类抓取进入数据库 外链 - 网站于网站之间的连接向导–通过链接去抓取 互联网是链接与链接实现的一条网络 与内容相近的网站交换 其他形式的交换， 例如-灌水式外链【在论坛，贴吧发布链接~】 内链 页面链接 【文章关键字链接】– 蜘蛛顺着链接爬来爬去抓取 优化本站质量、提高流量 内容质量 质量高能够提升权重 更新内容，增加匹配度-保持权重 原创 【抄袭， 洗稿子， 不长久，搜索引擎算法更新】 关键词密度 【2% – 8%】 【ps：一篇文章内的关键词链接】 黑帽和沙盒 购买外链 【在淘宝等与权重高德网站交换外链】 垃圾站 【seqing - dubo 等非法大流量网站进行交换】【降权惩罚，关进沙盒，搜索引擎扔进小黑屋】 黑客行为 【攻击网站，恶意添加外链】 话术设置example： – 原标题： 前端开发，如何才能高新就业 – 修改话术后： 一个菜鸟前端的百万年薪之路 关键词的挖掘 头脑风暴 利用搜索引擎的相关搜索 与排名靠前的网站使用相同的关键字， 蹭热度； 参考相关搜索中的关键词， 调整网站的关键字； 工具 工具-百度指数，对关键词查询 长尾关键词 使用关键词竞争对手少，但是也有一定量的关键词， 用户转换率高很多 域名的选择 后缀的选择 .com商业性强，输入自动填入 短域名 域名语义化 域名的使用历史查询 seo前端优化方案 代码去冗余 【精简代码、 模块化】 自动化【 工具 webpack~~~ 】 Html语义化【 P标签, h标签 a标签】 meat标签 – keywords – description title标签 其他方式 站群推广 –相同类似的网站互相链接，推广 日子分析推广工具 百度推广 百度统计 百度指数 CNZZ 爱站网 站长工具]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018上半年学习资料整理&学习计划[5]]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2Fstudy2014-05%2F</url>
    <content type="text"><![CDATA[每天收集一点，每天学习一点 前端 印记中文网 CSS css3视频教程 NestJS NestJS中文网 验证器class-validator 数据库api]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习（一）]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fnode%2Fnodestudy-01%2F</url>
    <content type="text"><![CDATA[tips: Api写法：Error-first Callback 和 EventEmitter a) 在node的回调中错误优先应该先定义错误的返回接收函数 回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。 回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。 123function(err, res) &#123; // process the error and result&#125; 语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。 b) EventEmitter事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过EventEmitter属性，提供了一个构造函数。该构造函数的实例具有 on 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 EventEmitter 实例的 on 方法监听到。 12345678910111213141516171819202122232425262728293031323334var EventEmitter = require('events').EventEmittervar life = new EventEmitter()// 设置可以添加的事件数量life.setMaxListeners(2)// 添加事件var water = function(who) &#123; console.log('给' + who + '倒杯水！')&#125;life.on('求安慰', water)life.on('求安慰', function(who) &#123; console.log('给' + who + '做饭！')&#125;)// ... 总共可以添加10个事件 【默认】// 超出会有报出异常// 触发事件life.emit('求安慰', '汉子')// 事件移除// 将回调函数具名化 移除某一个事件life.removeListener('求安慰', water)// 全部移除life.removeAllListeners()// 移除某一个事件life.removeListener('求安慰')// 检测事件是否监听var hasLifeListener = life.emit('求安慰', '')console.log('求安慰事件是否监听:' + hasLifeListener)// 检测事件监听的个数console.log('life 上添加的事件数量是:' + life.listeners('求安慰').length)console.log(EventEmitter.listenerCount(life, '求安慰')) c) bufferBuffer： 是一个对象， 是一个构造函数； 实例：V8引擎分配的一段内存；基本是一个数组，整数值；12345678910111213141516171819202122new Buffer(123)// &lt;Buffer 31 32 33&gt;默认编码格式 utf-8指定编码：new Buffer('123', 'base64')// &lt;Buffer d7 6d&gt;长度：var buf = new Buffer(8) buf.length // 8限制长度，写入会被截取var buf = new Buffer(6)buf.write('12345678')buf // &lt;Buffer 31 32 32 33 34 35&gt; 6位 超出不会被缓冲实例化数组，可以用下表读取到；var buf = new Buffer([1,2.22,3])buf[0] // 1buf[1] // 2 [自动取证] buffer转化 1234567&gt; var buf = new Buffer('12345')&gt; var str = buf.toString('base64')//&gt; str 'MTIzNDU='&gt; var buf2 = new Buffer(str, 'base64')&gt; var str2 = buf2.toString()// &gt; str2 12345]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解react中的constructor与super]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Freact%2Freact-constructor-super%2F</url>
    <content type="text"><![CDATA[react中的constructor与super constructor( )—–super( )的基本含义constructor( )——构造方法 这是ES6对类的默认方法，通过 new 命令生成对象实例时自动调用该方法。并且，该方法是类中必须有的，如果没有显示定义，则会默认添加空的constructor( )方法。 super( ) ——继承 在class方法中，继承是使用 extends 关键字来实现的。子类 必须 在 constructor( )调用 super( )方法，否则新建实例时会报错。 报错的原因是：子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。 Es5—–Es6关于继承的实现不同之处出现上面情况的原因是，ES5的继承机制与ES6完全不同。 复习一个重要知识点——ES5中new到底做了些啥？ 当一个构造函数前加上new的时候，背地里来做了四件事： 1.生成一个空的对象并将其作为 this； 2.将空对象的 __proto__ 指向构造函数的 prototype； 3.运行该构造函数； 4.如果构造函数没有 return 或者 return 一个返回 this 值是基本类型，则返回this；如果 return 一个引用类型，则返回这个引用类型。 简单解释，就是在ES5的继承中，先创建子类的实例对象this，然后再将父类的方法添加到this上（ Parent.apply(this) ）。而ES6采用的是先创建父类的实例this（故要先调用 super( )方法），完后再用子类的构造函数修改this。 super(props)——super()—–以及不写super的区别 如果你用到了constructor就必须写super(),是用来初始化this的，可以绑定事件到this上; 如果你在constructor中要使用this.props,就必须给super加参数：super(props)； （无论有没有constructor，在render中this.props都是可以使用的，这是React自动附带的；） 如果没用到constructor,是可以不写的；React会默认添加一个空的constructor。]]></content>
      <categories>
        <category>react框架</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018上半年学习资料整理&学习计划[4]]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2Fstudy2018-04%2F</url>
    <content type="text"><![CDATA[每天收集一点，每天学习一点 小程序 小程序登录鉴权-手把手 node.js –express node社区 express入门指南 Promise Promise 迷你书 理解 Promise 的工作原理 Node.js最新技术栈之Promise篇 axios axios中文文档 css css探索之旅 Web前端实验室 在线阴影生成方法 CSS3中的伪类 nth-child选择器 ESlint ESlint配置官网 ESlint配置官网(zh) ESlint知乎配置大全]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018上半年学习资料整理&学习计划[3]]]></title>
    <url>%2Fblog%2F2018%2Fstudy%2Fstudy2018-03%2F</url>
    <content type="text"><![CDATA[每天收集一点，每天学习一点 git使用学习 git快速学习教程-廖雪峰的网站 git使用原理文档 博客 胖芮的博客–很多学习的东西 博客框架的的例子 框架 vue快速入门，全家桶知识学习 其他 hexo官网 webpack学习 webpack小书 webpack【gitbook】]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取浏览器url 参数]]></title>
    <url>%2Fblog%2F2018%2Fjs%2Fcommon%2FparseUrlParams%2F</url>
    <content type="text"><![CDATA[1、获取当前url的方法：123当前url = 'https://www.jianshu.com/search?q=%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96&amp;page=1&amp;type=note'var href = window.location.href // 获取完整 url路径var search = window.location.search // 获取从？开始的参数部分 2、将url中的参数转换成中文 知识点 来自W3C 编码encodeURI() 解码decodeURI() 把字符串作为 URI 进行编码。 对 / ? : @ &amp; = + $ # 不会转义。 编码 encodeURIComponent() 解码 decodeURIComponent()12var src = '%2F2018%2F02%2F06%2Fjs%2Fcommon%2FparseUrlParams%2F'decodeURIComponent(src) // "/2018/02/06/js/common/parseUrlParams/" 把字符串作为 URI 组件进行编码。 不会对 ASCII 字母和数字进行编码， 也不会对这些 ASCII 标点符号 - _ . ! ~ * ‘ ( ) 进行编码： 其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 3、获取URL参数123url = decodeURI(search) // 编码字符 解码var splitIndex = url.indexOf('?') // 返回第一个？号的位置var str = url.substring(splitIndex + 1) // 获取到查询参数 3.1 获取url中某一个参数的值的方法1234567var getStrParam = function (str, name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = str.match(reg); if (r != null) return r[2]; return '';&#125; 3.2 获取url中所有的参数，序列在在一个对象中；12345678910var getAllUrlParam = function(str) &#123; var urlArr = str.split('&amp;') var obj = &#123;&#125; for(var i = 0; i &lt; urlArr.length; i++) &#123; var arg = urlArr[i].split('=') obj[arg[0]] = arg[1] &#125; return obj&#125; 一道练手题送给大家：将URL中的参数序列化在一个对象中，相同的key存放在一个数组中，值为空的key，默认为true？1var url = 'https://www.jianshu.com/search?q=%E5%8F%82%E6%95%B0&amp;page=1&amp;type=&amp;key=aa&amp;key=bb&amp;' 预期结果：123456obj = &#123; q: '参数', // 中文 page: "1", type: true, // 空值为ture key: ["aa", "bb"] // 相同的key放在数组中&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰：时间管理的七句话]]></title>
    <url>%2Fblog%2F2017%2Fothers%2Ftime-manage%2F</url>
    <content type="text"><![CDATA[时间对每一个人来说都是重要的，学会管理时间； 一、 进程切换非常昂贵，避免多任务，保持单进程。 不要同时做多件事，结果可能都没做好，还拖长了工作时间。 上图是多任务状态和单进程状态的对比，可以看到，多任务状态会花费更多的时间。 二、研究表明，集中注意力、高效工作，每天最多4小时。 一个人能够集中注意力的时间，是有限的。一般来说，高效工作只能持续四个小时，其余时间就都是低效工作了。 上图左侧是大多数人每天的时间分配，如果你能保证4个小时都高效工作，那么完全可以变成右侧的时间分配。 三、划分任务的优先级，不要把’急切’当作’重要’。 你的时间有限，不可能做所有事。最重要的事，应该首先做。（推荐阅读《什么是重要的事情？》） 一个有用的技巧是，将所有任务按照、重要性、和紧急性两个维度，分成四个象限。第一象限优先级最高，第四象限最低。 四、起床后，不要查看邮件和微信。 早晨精力最充沛，消耗在邮件和微信就太可惜了，应该用来做更重要的事。而且，邮件代表对别人优先级高，不等于对你优先级高。你的时间到底属于谁？你自己，还是某个给你写信的人？（推荐阅读《为什么起床后不能收邮件？》） 五、避免开会，因为人类已知的最浪费时间的事情，就是开会。 越大的公司，越无法避免开会。但至少不要参加与你无关的会。站着开会，也许是一个缩短会议时间的好办法。 六、早晨4点起床，到了中午，你就完成了一天的任务。 早晨4点起床开始工作，你会发现每天的时间多出了好多。有个日本人写了一本书《四点起床》，就是讲这个观点。 七、你没空时不会做的事情，有空了也不会做。 世上并没有拖延症，只是不想做而已。如果可能，应该尽早放弃你没有意愿去做的那些事。而那些没有时间也会去做的事，才是你应该全力以赴的人生方向。 来源： http://www.techug.com/post/time-management.html]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经过了这么多年的努力，理想终于成了泡影---猎场经典台词]]></title>
    <url>%2Fblog%2F2017%2Fothers%2Fmove-review-liechang%2F</url>
    <content type="text"><![CDATA[经典歌曲 : 一场恋爱 你的浏览器暂不支持！歌曲通过QQ音乐付费下载， 此处引用，如有侵权，联系删除 God gives every individual life time is very limited, if we do not for their own destiny scurry, traces of life is too short. 上天赋予每个生命个体的时间非常有限,若我们不为自己的命运疾走,生命的痕迹就显得太短浅了。 “如果记忆是一个罐头，我希望它永远不会过期”。 ———-引用自电影《重庆森林》 “时间是一个伟大的作者，它必将写出最完美的答案”。 ———引用自卓别林 “山中何所有 ，岭上多白云”。 —————-引用自陶弘景 岁月如刀，我似芹萝，时间太可怕了。 经过了这么多年的努力，理想终于成了泡影。 时间过得太快了 要是能倒着活就好了 所有的选择都是正确的人生就是满分——郑秋冬 女人不仅是个伴，还能让我活得不那么糙。 女人，是可以改变生活的。谈情说爱很辛苦，而你好像总是在偷懒。 我能见证你们的成长，那是我人生之大幸你们不发财天理难容我的今天，就是你们的明天，所以你们一定要对自己有信心打鸡血，撒狗血，流鼻血，直到血脉偾张 “退一步海阔天空”这话没错，“狭路相逢勇者胜”这话也没错，可它们的字面意思却是冲突的，人生就是体会矛盾的过程。 只要你还没钻进坟墓里，一切就只是开始。 职介所是帮助没有工作的人找工作，人力资源是帮优秀的人找更适合的职位，也就是网罗高级人才或挖掘高端人才。 这不就是我吗,即便作为猎头的同行，我也要跟你谈谈，禁止游戏的法则。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件的使用]]></title>
    <url>%2Fblog%2F2017%2Fframe%2Fvue%2Fvue-study-03%2F</url>
    <content type="text"><![CDATA[vue中组价的使用方式？description:]]></content>
  </entry>
  <entry>
    <title><![CDATA[iview组件使用的踩坑记录]]></title>
    <url>%2Fblog%2F2017%2Fframe%2Fvue%2Fvue-study-iview%2F</url>
    <content type="text"><![CDATA[级联选择器的校验， 导航Tabs的使用 级联选择起的校验2017-11-08 16:03:39 html1234567 &lt;Form :label-width="100" ref="formData" :rules="ruleValidate" :model="formData" inline class="wms-form-check oneline"&gt; &lt;Form-item label="收货地址：" style="width:532px" prop="region" `@注意region`&gt; &lt;Cascader :data="provinceCity" v-model="formData.region" `@注意region` size="small" trigger="hover"&gt;&lt;/Cascader&gt; &lt;/Form-item&gt;&lt;Form&gt; javascript1234567891011121314151617181920212223242526import wmsValidate from 'wmsValidatedata() &#123; return &#123; formData: &#123; region: [] &#125;, ruleValidate: &#123; ownerName: [&#123;required: true, message: '货主名称不能为空', trigger: 'change'&#125;], type: [&#123;required: true, message: '单据类型不能为空', trigger: 'change'&#125;], contactsName: [&#123;required: true, message: '联系人不能为空', trigger: 'blur'&#125;], contacts: [&#123;required: true, message: '联系方式不能为空', trigger: 'blur'&#125;], region: [ --@注意-- &#123; validator: wmsValidate.proviinceValidate, required: true, trigger: 'change', fullField: 'address' &#125;], address: [&#123;required: true, message: '详细地址不能为空', trigger: 'blur'&#125;], shippingMethod: [&#123;required: true, message: '送货方式不能为空', trigger: 'change'&#125;] &#125;, &#125;&#125; 检验地址控件的方法1234567891011 // 校验地址控件选择 必填, 不能双向绑定 改变数据export default class wmsValidate &#123; static proviinceValidate(rule, value, callback) &#123; if (_.isArray(value) &amp;&amp; value.length === 3) &#123; return callback() &#125; else &#123; return callback(new Error('地址不能为空')) &#125; &#125;&#125; Tisp： v-model绑定的名字，prop的名字，和validate中的名字必须一致，validate中才能接收到值 iview中tabs的使用2017-11-15 09:46:55 正确使用姿势：12345&lt;Tabs v-if="pageName!=='detail'" type="card" class="wms-mt10 wms-tabs"&gt; &lt;Tab-pane label="出库箱信息"&gt; &lt;/Tab-pane&gt;&lt;/Tabs&gt;&lt;div v-if="pageName!=='detail'"&gt; &lt;/div&gt; Tisp：： 不能将Tabs放在 带有v-if属性的div中 iview中Model弹窗二次点击依然会关闭问题2017-11-16 18:39:55 确定按钮点击 –会自动关闭Model, 添加属性 :loading后需要在@on-ok事件中手动去设置关闭 Tips: :loading初始值为要设置为 true 问题： 首次点击未手动设置model关闭， 再次点击依然会自动关闭？ 场景： html 123456789&lt;Modal v-model="syncUploadPop" title="title" width="400" :mask-closable="false" @on-ok="accountUnload" :loading="uploadLoading" &gt;&lt;/Model&gt; js 12345678910111213141516171819202122232425262728 data() &#123; return &#123; syncUploadPop: false, // 弹出款默认不显示 uploadLoading: true // 上传中 &#125; &#125;methods: &#123; async accountUnload() &#123; this.uploadLoading = true // 确定点击显示 加载中、、、 let res = await request.post(InterObj.accountUnloadTo, params) this.uploadLoading = false // 请求成功取消 加载中、、、 // -------解决问题的核心代码------ this.$nextTick(() =&gt; &#123; this.uploadLoading = true &#125;) // -------解决问题的核心代码------ if(res.result === 'success') &#123; this.$Message.success(res.msg) this.syncUploadPop = false &#125; else &#123; this.$Message.error(res.msg) &#125; &#125;,&#125; 总结： :loading设置成false取消 加载中状态后，需要在线程最后依然将 他设置为true]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>iview组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中的计算属性 computed]]></title>
    <url>%2Fblog%2F2017%2Fframe%2Fvue%2Fvue-study-computed%2F</url>
    <content type="text"><![CDATA[vue中使用计算属性 computed html Vue: 12345678&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;cpu_number&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;cpu_numObj&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;cpu_numObj2&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; javaScript: 123456789101112131415161718192021data() &#123; return &#123; number: 1, numObj: &#123;&#125;, numObj2: &#123;&#125;, &#125;&#125;,computed: &#123; cpu_number: function() &#123; return this.number ++ &#125;, cpu_numObj: function() &#123; this.numObj.type = '直接改变对象属性' // 计算属性不会检测到 return numObj.type &#125; cpu_numObj2: function() &#123; this.numObj2 = Object.assign(&#123;&#125;, &#123;type: '改变了对象索引'&#125;) // 计算属性会检测到 return numObj2 &#125;&#125; 总结： vue 计算属性computed可以检测到 变量 数组 对象的变化； 但是 对象的属性变化是不会被检测到的]]></content>
      <categories>
        <category>vue框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每个JavaScript程序员都需要知道的5个数组方法]]></title>
    <url>%2Fblog%2F2017%2Fjs%2Farray%2Farray-method-01%2F</url>
    <content type="text"><![CDATA[Array.forEach() .forEach() 方法能够方便的让你 遍历数组里的每个元素，你可以在回调函数里对每个元素进行操作。 .forEach()方法没有返回值，你不需要在回调函数里写return，这是无意义的。 1234567var score = ['9', '13', '10'];score.forEach(function(item, index)&#123; console.log(item, index)&#125;); // 9 0 // 13 1 // 10 2 Array.map() .map() 方法能够遍历整个数组，然后 返回一个新数组，这个新数组里的元素是经过了指定的回调函数处理过的。如果你想修改数组里的每个元素，然后将修改后的数组存入新的数组，那使用 .map() 方法最方便。 123456var numbers = [2, 4, 6, 8];var doubleNums = numbers.map(function(element) &#123; return element * 2;&#125;);console.log('doubleNums: ', doubleNums) Array.filter() .filter() 方法能够 过滤掉数组中的某些元素，你可以在回调函数里设定条件，不符合条件的元素都会排除在外。 1234567891011var scores = [3, 12, 5, 23, 19, 7];var topScores = scores.filter(function(item)&#123; if (item &gt; 10)&#123; return true; &#125; else &#123; return false; &#125;&#125;);console.log('topScores: ', topScores); Array.indexOf() indexOf() 能够告诉你 某个元素在数组中的位置，它返回的是索引值，如果数组里有重复的元素，它会返回第一个元素的位置。 1234567var a = [2, 9, 9, 18];var i = a.indexOf(9);console.log('i: ', i);/*if (a.indexOf(7) === -1) &#123; // 数组中没有这个元素&#125;*/ Array.every() .every() 方法的作用是用指定的回调函数去检查数组中的每个元素，如果对于每个元素，这个回调函数都返回true，则.every()返回true。否则，.every() 返回false。如果你想知道数组中的所有元素都是否符合某种条件，使用 .every() 最方便。 1234567var ages = [23, 19, 32, 44];var olderThan18 = ages.every(function(element) &#123; return element &gt; 18;&#125;);console.log('olderThan18: ', olderThan18); Tips: 上面的这5个方法只是很多JavaScript方法中关于数组的最重要的几个，还有很多关于数组的方法、工具包(lodash and underscore)等都非常的有用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript之call的用法]]></title>
    <url>%2Fblog%2F2017%2Fjs%2Farray%2Fjs-call%2F</url>
    <content type="text"><![CDATA[正文开始一说到call， ————总是call、‘张三’、‘李四’的区别什么什么的，说的很清楚，转身还是傻傻分不清楚他们的区别了，相似的事情总是喜欢一起来说，这对于新手来说总是容易混乱的，今天就来理解下call的用法； 通俗点： call的作用就是： 改变函数执行时的上下文 也就是this的指向; 用法：Food.call(thisArg, arg1, arg2, ...) 来看个例子 — A123456789101112131415function fun()&#123; this.name = 'fun-name' this.age = 'fun-age'&#125; var wrap = &#123; age: 'default', name: 'default', myfun: function() &#123; fun() &#125;&#125;wrap.myfun();console.log(wrap.age) // 'default-age'console.log(window.age) // 'fun-age' 直接运行这个函数 wrap.myfun(); 执行这个函数后1、在wrap下面执行myfun()后，其中的this指向window全局的2、在window全局下面创建了一个 age属性，值为 &#39;fun-age&#39;3、wrap中的age还是default 来看个例子 — B123456789101112131415function fun()&#123; this.name = 'fun-name' this.age = 'fun-age'&#125; var wrap = &#123; age: 'default', name: 'default', obj: function() &#123; fun.call(this) // **---注意这里打 call 了---** &#125;&#125;wrap.myfun();console.log(wrap.age) // 'fun-age' --发生了变化---console.log(window.age) // 'age is not defined' --发生了变化--- 例子B运行时： wrap.obj()执行后，在执行fun时，把this， call进去了, 这个this是指向wrap，所以fun执行时其中的this指向的是wrap，自然改变的就是wrap中的age，这就是call的作用改变了fun执行时的上下文； 好累，反正我是大概懂了他（this）刚才干了什么； 那么在我们的coding中，一般什么时候用到call了？ call的用法利用call来 做继承1234567891011var Person = function () &#123; this.fun = function() &#123; console.log('longlee') &#125;&#125;;var student = function () &#123; Person.call(this);&#125;;var st = new student ();g1.fun() // 输出： longlee 如果不在student函数中执行 call，new出来的实例是没有fun属性方法的；打call就可以实现继承Person方法了； 判断数据的类型【object、 array、 null】12345678910var obj1 = &#123;name: 'longlee'&#125;var obj2 = ['longlee']var obj3 = nullObject.prototype.toString.call(obj1) // "[object Object]"Object.prototype.toString.call(obj2) // "[object Array]"Object.prototype.toString.call(obj3) // "[object Null]"Object.prototype.toString.call(12) // "[object Number]"........ 类（伪）数组使用数组方法12345var arg = Array.prototype.slice.call(arguments);arguments是函数接收的实际参数个数，他是一个伪数组，不具有数组的一般方法。比如 push、pop...,但是我们能通过 Array.prototype.slice.call 转换为真正的数组这样 arguments 就可以应用 Array 下的所有方法了。 获取数组中的最大值和最小值12maxInNumbers = Math.max.call(Math, 55, 888 , 521 , -36); // 888number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 使用其方法。 就说到这了，再说下去，我自己也快消化不良了、、、、 题外话：说到数组的最大值、最小值。我控制不住自己了，一个ES6的简洁方法Math.max(...[2,1,3]) // 3Math.min(...[2,1,3]) // 1 个人见解，有误之处，大神请指出，以免改正！弄懂 call 了。可以继续打 call 了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我忘记了自己，却没忘记你！]]></title>
    <url>%2Fblog%2F2017%2Fothers%2Flive-tulei-01%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一位老人找不到家了，他连自己的名字也忘记了，民警在他身上找到两样东西，一封40年前他写给爱人的信，和一张17年前爱人离世火化的证明。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信的落款是1977年4月30日，名字的落款是“生”，信的开头是“亲爱的馨”。根据图片和信的内容来推算，写这封信的时候，他的妻子“馨”应该是43岁。信中所写都是些家长里短，对爱人身体的关心，工作和生活的琐事。唯有信中有两处最感人的地方，一处是对爱人的称呼是“您”，一处是信的结尾，“一切尚好，不要挂念，好好保重身体。”经了解，老人名叫张连生，今年87岁，妻子名叫孙懿馨，2000年离世，享年66岁！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一封40年前的信，一张17年前的火化证明，张老先生随身携带着这两样东西，尽管年事已高，忘却了很多往事，甚至是回家的路，却始终没忘了自己的爱人！我理解老人随身带着书信，是因为见字如面，但是为什么还带着一纸火化证明？我的妻子说，因为那是他爱人火化之前最后停留的地方！是的，17年前，张老先生看着爱人的遗体即将推进火化炉时，那是他看见爱人的最后一面，所有的爱都定格在了那一刻！从此，一封信，一张火化证明，就成为了爱人的全部，找不到回家的路不要紧，只要这两样东西在，老伴就在，家就在！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想，多数人看到这样的故事，都会被深深的感动！因为这样的爱情，如今已经不多见。男人不再长情却多情，女人不再痴情更绝情！我们表达爱情的词汇越来越丰富，方式越来越浪漫，但华丽的背后是苍白！陪伴是最长情的告白！你若不离不弃，我必生死相依！等等，这样的语句无数次感动我们，但感动过后，往往一切照旧！如同此时的正在听故事的你们，也一定感动得潸然泪下，可是泪水过后，又会有多少实质性的改变？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天我讲述这个故事，并不只是要感动你们，那不是这个故事真正的意义。我想说的是，生活是由普普通通的每一天组成，吃喝拉撒上班下班，枯燥的循环往复是生活的大多数，激情与浪漫只是偶尔的点缀。因为一张火化证明，我们被老人的深情思念所打动，但是要知道，在他爱人逝去的这17年，老先生每天都是这样度过。因为一封书信，我们感动于老人们往日的恩爱如初，但几十年如一日的相敬如宾，我们又能否做到？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动人的爱情故事往往如此，一日的相爱是平凡，日复一日的相守是经典！观众们热泪盈眶，深受感动，但被感动很容易，要去付出感动对方却很难！主人公却并不觉得这有多么值得歌颂，因为他所做的这一切，既不为了感动对方，也不是为了感动自己，因为，那就是爱情本来的样子，这一切的一切，不为别的，只是因为爱情 ！ 本文转载自： 涂磊公众号]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 命令集合]]></title>
    <url>%2Fblog%2F2017%2Fothers%2Fhexo-command%2F</url>
    <content type="text"><![CDATA[快速开始创建一篇文章1$ hexo new "My New Post" "tags" 更多信息: Writing 启动服务12$ hexo server$ hexo s 更多信息: Server 打包构建静态文件1$ hexo generate 更多信息: Generating [发布站点]1$ hexo deploy 更多信息: Deployment http://blog.csdn.net/qq_23435721/article/details/50997275 添加搜索的方法1npm install hexo-generator-search --save 更多信息: 站内搜索更多信息: github地址 seo优化12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 更多信息: 优化教程更多信息: 优化教程更多信息: 优化教程 首页显示tag的两种方法 方法一 123456title: Hello Worlddate: 2000-12-03 00:00:00---&lt;Excerpt in index | 首页摘要&gt; +&lt;!-- more --&gt;&lt;The rest of contents | 余下全文&gt; 方法二 12345title: Hello Worlddate: 2000-12-03 00:00:00+description: "Welcome to Hexo! This is your very first post."---&lt;Contents&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo书写语法]]></title>
    <url>%2Fblog%2F2017%2Fothers%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo 创建一个新页面的方法命令 hexo new layout title tags layout会默认使用scaffolds中的post模板来生成一个新页面 简写命令 hexo new &#39;title&#39; tags 摘要内置标签1&#123;% note class_name %&#125; 内容 &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger default primary… success… info… warning… danger… 123# 添加代码文件方法 -- 默认目录在 downloads/code 下；&#123;% include_code appjs lang:javascript cssbreak.html %&#125; &#123;% iframe http://localhost:4000/downloads/code/cssbreak.html 600 600 %&#125; # 插入ifram方法]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
